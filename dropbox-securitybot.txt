Directory structure:
└── dropbox-securitybot/
    ├── setup.cfg
    ├── main.py
    ├── tests/
    │   ├── bot_test.py
    │   ├── user_test.py
    │   ├── __init__.py
    │   ├── state_machine_test.py
    │   └── util_test.py
    ├── scripts/
    │   ├── custom_alert.py
    │   └── query_db.py
    ├── .travis.yml
    ├── .eslintrc.js
    ├── frontend/
    │   ├── securitybot_api.py
    │   ├── securitybot_frontend.py
    │   ├── __init__.py
    │   ├── templates/
    │   │   └── index.html
    │   └── static/
    │       ├── css/
    │       │   └── main.css
    │       └── js/
    │           └── main.js
    ├── plugins/
    │   ├── splunk/
    │   │   ├── apps/
    │   │   │   └── securitybot_alerts/
    │   │   │       ├── appserver/
    │   │   │       │   └── static/
    │   │   │       ├── bin/
    │   │   │       │   ├── bot_lookup.py
    │   │   │       │   ├── send_bot_alerts.sh
    │   │   │       │   ├── send_bot_alerts.py
    │   │   │       │   └── bot_lookup_launcher.py
    │   │   │       ├── metadata/
    │   │   │       │   └── default.meta
    │   │   │       └── default/
    │   │   │           ├── app.conf
    │   │   │           ├── restmap.conf
    │   │   │           ├── alert_actions.conf
    │   │   │           ├── data/
    │   │   │           │   └── ui/
    │   │   │           │       └── alerts/
    │   │   │           │           └── send_bot_alerts.html
    │   │   │           ├── macros.conf
    │   │   │           └── transforms.conf
    │   │   └── README.md
    │   └── README.md
    ├── securitybot/
    │   ├── ignored_alerts.py
    │   ├── auth/
    │   │   ├── __init__.py
    │   │   ├── duo.py
    │   │   └── auth.py
    │   ├── commands.py
    │   ├── __init__.py
    │   ├── state_machine.py
    │   ├── blacklist/
    │   │   ├── sql_blacklist.py
    │   │   ├── __init__.py
    │   │   └── blacklist.py
    │   ├── tasker/
    │   │   ├── __init__.py
    │   │   ├── tasker.py
    │   │   └── sql_tasker.py
    │   ├── chat/
    │   │   ├── chat.py
    │   │   ├── __init__.py
    │   │   └── slack.py
    │   ├── bot.py
    │   ├── user.py
    │   ├── util.py
    │   └── sql.py
    ├── requirements.txt
    ├── config/
    │   ├── commands.yaml
    │   ├── bot.yaml
    │   └── messages.yaml
    ├── util/
    │   └── db_up.py
    ├── frontend.py
    ├── LICENSE
    └── README.md

================================================
File: /setup.cfg
================================================
[flake8]
select = D,E101,E401,E901,F,H201,W191,W402
max-line-length = 100
max-complexity = 50




================================================
File: /main.py
================================================
#!/usr/bin/env python
import logging

from securitybot.bot import SecurityBot
from securitybot.chat.slack import Slack
from securitybot.tasker.sql_tasker import SQLTasker
from securitybot.auth.duo import DuoAuth
from securitybot.sql import init_sql
import duo_client

CONFIG = {}
SLACK_KEY = 'slack_api_token'
DUO_INTEGRATION = 'duo_integration_key'
DUO_SECRET = 'duo_secret_key'
DUO_ENDPOINT = 'duo_endpoint'
REPORTING_CHANNEL = 'some_slack_channel_id'
ICON_URL = 'https://dl.dropboxusercontent.com/s/t01pwfrqzbz3gzu/securitybot.png'

def init():
    # Setup logging
    logging.basicConfig(level=logging.DEBUG,
                        format='[%(asctime)s %(levelname)s] %(message)s')
    logging.getLogger('requests').setLevel(logging.WARNING)
    logging.getLogger('usllib3').setLevel(logging.WARNING)

def main():
    init()
    init_sql()

    # Create components needed for Securitybot
    duo_api = duo_client.Auth(
        ikey=DUO_INTEGRATION,
        skey=DUO_SECRET,
        host=DUO_ENDPOINT
    )
    duo_builder = lambda name: DuoAuth(duo_api, name)

    chat = Slack('securitybot', SLACK_KEY, ICON_URL)
    tasker = SQLTasker()

    sb = SecurityBot(chat, tasker, duo_builder, REPORTING_CHANNEL, 'config/bot.yaml')
    sb.run()

if __name__ == '__main__':
    main()


================================================
File: /tests/bot_test.py
================================================
from unittest2 import TestCase
from mock import Mock, patch

import yaml
import types
import os.path
import pytz
from datetime import datetime

import securitybot.bot as bot
import securitybot.commands as commands
import securitybot.user
import securitybot.chat.chat

MAIN_CONFIG = 'config/bot.yaml'
COMMAND_CONFIG = 'config/commands.yaml'
MESSAGE_CONFIG = 'config/messages.yaml'

@patch('securitybot.chat.chat.Chat', autospec=True)
def fake_init(self, tasker, auth_builder, reporting_channel, client):
    self.username = 'testing-bot'
    self.tasker = tasker
    self.auth_builder = auth_builder
    self.reporting_channel = reporting_channel
    self._last_task_poll = datetime.min.replace(tzinfo=pytz.utc)
    self._last_report = datetime.min.replace(tzinfo=pytz.utc)

    self.chat = client

    self.users = {}
    self.users_by_name = {}
    self.active_users = {}

    self.commands = {}

    self.messages = {}

bot.SecurityBot.__init__ = fake_init

class ConfigTest(TestCase):
    # Validate configuration files
    def test_config(self):
        '''Tests bot.yaml.'''
        with open(MAIN_CONFIG) as f:
            config = yaml.safe_load(f)
            for path in [s + '_path' for s in ['messages', 'commands']]:
                assert path in config, 'No {0} provided'.format(path.replace('_', ' '))
                # Test that files exist
                assert os.path.isfile(config[path]), '{0} missing'.format(path.replace('_', ' '))

    def test_commands(self):
        '''Tests commands.yaml'''
        with open(COMMAND_CONFIG) as f:
            config = yaml.safe_load(f)
            for name, items in config.items():
                assert 'info' in items, 'No info provided for {0}'.format(name)
                assert 'fn' in items, 'No function provided for {0}'.format(name)
                assert isinstance(getattr(commands, items['fn'], None), types.FunctionType), \
                    '{0}: {1} is not a function'.format(name, items['fn'])

    def test_messages(self):
        '''Tests messages.yaml.'''
        with open(MESSAGE_CONFIG) as f:
            config = yaml.safe_load(f)
            for name, string in config.items():
                assert type(string) is str, 'All messages must be strings.'

class BotMessageTest(TestCase):
    '''
    Tests different kinds of message handling.
    '''
    def setUp(self):
        self.bot = bot.SecurityBot(None, None, None)
        self.bot.messages['bad_command'] = 'bad-command'
        self.bot.users = {'id': {'id': 'id', 'name': 'name'}}

    def test_handle_messages_command(self):
        '''Test receiving a command.'''
        self.bot.commands = {'test': None}
        self.bot.handle_command = Mock()
        self.bot.chat.get_messages.return_value = [{'type': 'message',
                                                    'user': 'id',
                                                    'channel': 'D12345',
                                                    'text': 'test command'}]
        self.bot.handle_messages()
        self.bot.handle_command.assert_called_with(self.bot.users['id'], 'test command')

    def test_handle_messages_not_command(self):
        '''Test receiving a message that isn't a command.'''
        self.bot.commands = {'test': None}
        self.bot.message_user = Mock()
        self.bot.chat.get_messages.return_value = [{'type': 'message',
                                                    'user': 'id',
                                                    'channel': 'D12345',
                                                    'text': 'not a command'}]
        self.bot.handle_messages()
        self.bot.chat.message_user.assert_called_with(self.bot.users['id'], 'bad-command')

    def test_handle_messages_not_dm(self):
        '''Test receiving a message that's not from a DM channel.'''
        self.bot.user_lookup = Mock()
        self.bot.chat.get_messages.return_value = []
        self.bot.handle_messages()
        assert not self.bot.user_lookup.called, 'No user should have been looked up'

class BotCommandTest(TestCase):
    '''
    Tests handling a command.
    '''

    def test_command_success(self):
        b = bot.SecurityBot(None, None, None)
        mock_command = Mock()
        mock_command.return_value = True
        b.commands = {'test': {'fn': mock_command, 'success_msg': 'success_msg'}}
        user = {'id': '123', 'name': 'test-user'}
        b.handle_command(user, 'test command')
        mock_command.assert_called_with(b, user, ['command'])
        b.chat.message_user.assert_called_with(user, 'success_msg')

    def test_command_failure(self):
        b = bot.SecurityBot(None, None, None)
        mock_command = Mock()
        mock_command.return_value = False
        b.commands = {'test': {'fn': mock_command, 'failure_msg': 'failure_msg'}}
        user = {'id': '123', 'name': 'test-user'}
        b.handle_command(user, 'test command')
        mock_command.assert_called_with(b, user, ['command'])
        b.chat.message_user.assert_called_with(user, 'failure_msg')

class BotTaskTest(TestCase):
    '''
    Tests handling of tasks.
    '''

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.tasker.tasker.Tasker', autospec=True)
    def setUp(self, tasker, patch_task):
        self.bot = bot.SecurityBot(tasker, None, None)
        self.bot.greet_user = Mock()
        self.bot.blacklist = Mock()
        self.bot.blacklist.is_present.return_value = False

        self.patch_task = patch_task
        self.task = patch_task.start()
        self.task.title = 'title'
        self.task.username = 'user'
        self.task.comment = ''

        tasker.get_new_tasks.return_value = [self.task]
        tasker.get_pending_tasks.return_value = [self.task]

        self.user = securitybot.user.User({'id': 'id', 'name': 'user'}, None, self.bot)
        self.bot.users_by_name = {'user': self.user}

        import securitybot.ignored_alerts as ignored_alerts
        self.ignored_alerts = ignored_alerts
        ignored_alerts.__update_ignored_list = Mock()
        ignored_alerts.get_ignored = Mock(return_value={})
        ignored_alerts.ignore_task = Mock()

    def tearDown(self):
        self.patch_task.stop()

    def test_new_task(self):
        '''
        Tests receiving a new task that is neither for a blacklisted
        user or an ignored task.
        '''
        self.bot.handle_new_tasks()
        self.bot.greet_user.assert_called_with(self.user)
        assert self.user['id'] in self.bot.active_users

    def test_blacklisted_task(self):
        '''Tests receiving a new task that is blacklisted.'''
        self.bot.blacklist.is_present.return_value = True
        self.bot.handle_new_tasks()
        assert self.task.comment == 'blacklisted'
        self.task.set_verifying.assert_called_with()

    def test_ignored_task(self):
        '''Tests receiving a new task that is ignored by the user.'''
        self.ignored_alerts.get_ignored = Mock(return_value={'title': 'ignored'})
        self.bot.handle_new_tasks()
        assert self.task.comment == 'ignored'
        self.task.set_verifying.assert_called_with()

    def test_no_user_task(self):
        '''Tests a task assigned to an unknown or invalid username.'''
        self.task.username = 'another user'
        self.bot.handle_new_tasks()
        assert self.task.comment == 'invalid user'
        self.task.set_verifying.assert_called_with()

class BotUserTest(TestCase):
    def test_populate(self):
        '''
        Tests populating users.
        '''
        sb = bot.SecurityBot(None, lambda *args: None, None)
        user = {'id': 'id', 'name': 'name'}
        sb._api_call = Mock()
        sb.chat.get_users.return_value = [user]
        sb._populate_users()
        sb.chat.get_users.assert_called_with()
        assert user['id'] in sb.users
        assert user['name'] in sb.users_by_name

    @patch('securitybot.user.User', autospec=True)
    def test_step(self, user):
        '''
        Tests stepping over all users on a user step.
        '''
        sb = bot.SecurityBot(None, None, None)
        sb.active_users = {'key': user}
        sb.handle_users()
        user.step.assert_called_with()

class BotHelperTest(TestCase):
    '''
    Test cases for help functions in the bot that don't require
    actually constructing a bot properly.
    '''

    # User handling tests
    def test_user_lookup(self):
        '''Tests user lookup on ID.'''
        sb = bot.SecurityBot(None, None, None)
        user = {'id': 'id', 'name': 'user'}
        sb.users = {user['id']: user}
        assert sb.user_lookup('id') == user
        try:
            sb.user_lookup('not-a-real-id')
        except Exception:
            return
        assert False, 'A user should not have been found.'

    def test_user_lookup_by_name(self):
        '''Tests user lookup on ID.'''
        sb = bot.SecurityBot(None, None, None)
        user = {'id': 'id', 'name': 'user'}
        sb.users_by_name = {user['name']: user}
        assert sb.user_lookup_by_name('user') == user
        try:
            sb.user_lookup_by_name('not-a-real-user')
        except Exception:
            return
        assert False, 'A user should not have been found.'

    def test_valid_user_valid(self):
        '''Tests valid_user with a valid user.'''
        sb = bot.SecurityBot(None, None, None)
        user = {'id': '1234', 'name': 'mock-user'}
        sb.users = {user['id']: user}
        sb.users_by_name = {user['name']: user}
        assert sb.valid_user('mock-user')

    def test_valid_user_invalid(self):
        '''Tests valid_user with an invalid user.'''
        sb = bot.SecurityBot(None, None, None)
        user = {'id': '1234', 'name': 'mock-user'}
        sb.users = {user['id']: user}
        sb.users_by_name = {user['name']: user}
        assert not sb.valid_user('fake-user')

    def test_valid_user_malformed(self):
        '''Tests valid_user with a malformed user.'''
        sb = bot.SecurityBot(None, None, None)
        user = {'id': '1234', 'name': 'mock-user'}
        sb.users = {user['id']: user}
        sb.users_by_name = {user['name']: user}
        assert not sb.valid_user('mock-user\nfake-user')

    def test_valid_user_empty(self):
        '''Tests valid_user with a malformed user.'''
        sb = bot.SecurityBot(None, None, None)
        user = {'id': '1234', 'name': 'mock-user'}
        sb.users = {user['id']: user}
        sb.users_by_name = {user['name']: user}
        assert not sb.valid_user('')

    def test_cleanup_user(self):
        '''
        Test users being cleaned up properly.

        ... or at least the active_users dictionary having an element removed.
        '''
        # We'll mock a user using a dictionary since that's easier...
        user = {'id': '1234', 'name': 'mock-user'}
        fake_user = {'id': '5678', 'name': 'fake-user'}
        sb = bot.SecurityBot(None, None, None)
        sb.active_users = {user['id']: user}
        assert len(sb.active_users) == 1
        sb.cleanup_user(fake_user)
        assert len(sb.active_users) == 1
        sb.cleanup_user(user)
        assert len(sb.active_users) == 0

    # Command parsing tests
    def test_parse_command(self):
        '''Test parsing simple commands.'''
        sb = bot.SecurityBot(None, None, None)
        assert sb.parse_command('command text') == ('command', ['text'])
        assert sb.parse_command('command unquoted text') == ('command', ['unquoted', 'text'])
        assert sb.parse_command('command "quoted text"') == ('command', ['quoted text'])

    def test_parse_punctuation(self):
        '''Test parsing with punctuation in the command.'''
        sb = bot.SecurityBot(None, None, None)
        root = 'command'
        # Minimal set of punctuation to always avoid
        for char in bot.PUNCTUATION:
            assert sb.parse_command(root + char) == (root, [])

    def test_parse_nl_command(self):
        '''Test parsing commands that contain text in natural language.'''
        sb = bot.SecurityBot(None, None, None)
        command = 'command With some language.'
        assert sb.parse_command(command) == ('command', ['With', 'some', 'language.'])
        command = 'command I\'m cool.'
        assert sb.parse_command(command) == ('command', ['I\'m', 'cool.'])

    def test_parse_unicode(self):
        '''Tests parsing a command with unicode.'''
        sb = bot.SecurityBot(None, None, None)
        command = u'command \u2014flag'
        assert sb.parse_command(command) == ('command', ['--flag'])
        command = u'command \u201cquoted text\u201d'
        assert sb.parse_command(command) == ('command', ['quoted text'])


================================================
File: /tests/user_test.py
================================================
from unittest2 import TestCase
from mock import Mock, patch

from collections import defaultdict
from datetime import timedelta
from time import sleep

import securitybot.user as user
import securitybot.bot
import securitybot.chat.chat
import securitybot.auth.auth

# Mock away ignoring alerts
import securitybot.ignored_alerts as ignored_alerts
ignored_alerts.__update_ignored_list = Mock()
ignored_alerts.get_ignored = Mock(return_value={})
ignored_alerts.get_ignored.return_value = {}
ignored_alerts.ignore_task = Mock()

class UserTest(TestCase):
    @patch('securitybot.chat.chat.Chat', autospec=True)
    @patch('securitybot.bot.SecurityBot', autospec=True)
    def setUp(self, bot, chat):
        bot.chat = chat
        self.bot = bot

    def test_construction(self):
        '''Tests basic construction of a user.'''
        user.User({}, None, None)

    def test_get_attributes(self):
        '''Tests grabbing attributes like a dictionary.'''
        test_user = user.User({'alphabet': 'soup',
                               'animal': 'crackers'},
                               None, None)
        assert test_user['alphabet'] == 'soup'
        assert test_user['animal'] == 'crackers'

    def test_name(self):
        '''Tests getting a user's name.'''
        test_user = user.User({'profile': {'first_name': 'Bot'}}, None, None)
        assert test_user.get_name() == 'Bot'
        test_user = user.User({'profile': {}, 'name': 'Bot2'}, None, None)
        assert test_user.get_name() == 'Bot2'

    # User interaction flows

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_basic_flow(self, auth, mock_task):
        '''
        Tests basic flow through the bot.
        This is the most basic flow:
            new task => did perform => allow 2FA => valid 2FA => no task
        This will ensure that the states progress as expected and the bot
        cleans itself up afterwards.
        '''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.NONE
        auth.can_auth.return_value = True
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        # Also test not advancing on no queued task
        test_user.step()
        assert str(test_user._fsm.state) == 'need_task'

        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'auth_permission_check'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'waiting_on_auth'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.AUTHORIZED
        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'

        test_user.step()
        self.bot.cleanup_user.assert_called_with(test_user)
        assert str(test_user._fsm.state) == 'need_task'
        task.set_verifying.assert_called_with()

        mock_task.stop()

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_did_not_do_flow(self, auth, mock_task):
        '''
        Tests flow if a user did not perform an action.
        '''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.NONE
        auth.can_auth.return_value = True
        self.bot.messages = defaultdict(str)
        self.bot.reporting_channel = None
        test_user = user.User({}, auth, self.bot)

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        # Also test not advancing on no queued task
        test_user.step()
        assert str(test_user._fsm.state) == 'need_task'

        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        test_user.negative_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        mock_task.stop()

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_two_task_flow(self, auth, mock_task):
        '''
        Tests two task. Once the first is completed, the bot should send a
        a message announcing that another task exists.
        '''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.NONE
        auth.can_auth.return_value = True
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)
        test_user.send_message = Mock()

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        # Add two tasks to the queue
        test_user.add_task(task)
        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'auth_permission_check'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'waiting_on_auth'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.AUTHORIZED
        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'

        test_user.step()
        test_user.send_message.assert_called_with('bwtm')
        assert str(test_user._fsm.state) == 'need_task'
        task.set_verifying.assert_called_with()

        mock_task.stop()

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_already_authorized_flow(self, auth, mock_task):
        '''
        Tests already being authorized after confirming an alert.
        This is the most basic flow:
            new task => did perform => already authorized => no task
        '''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.AUTHORIZED
        auth.can_auth.return_value = True
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        test_user.step()
        self.bot.cleanup_user.assert_called_with(test_user)
        assert str(test_user._fsm.state) == 'need_task'
        task.set_verifying.assert_called_with()

        mock_task.stop()

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_no_2fa(self, auth, mock_task):
        '''
        Tests a user not having 2FA capability.
        This is the most basic flow:
            new task => did perform => allow 2FA => valid 2FA => no task
        '''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.NONE
        auth.can_auth.return_value = False
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        test_user.step()
        assert str(test_user._fsm.state) == 'need_task'

        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        test_user.step()
        self.bot.cleanup_user.assert_called_with(test_user)
        assert str(test_user._fsm.state) == 'need_task'
        task.set_verifying.assert_called_with()

        mock_task.stop()

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_not_allow_2fa_flow(self, auth, mock_task):
        '''
        Tests if the user denies being sent a Duo Push.
        '''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.NONE
        auth.can_auth.return_value = True
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        # Also test not advancing on no queued task
        test_user.step()
        assert str(test_user._fsm.state) == 'need_task'

        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'auth_permission_check'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        test_user.negative_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        mock_task.stop()
    # Putting escalation time in the past to make sure tests outsisde of
    # business hours won't fail
    @patch('securitybot.user.ESCALATION_TIME', timedelta(weeks=-1))
    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_auto_escalate(self, auth, mock_task):
        '''Tests that after some time an alert automatically escalates.'''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.DENIED
        auth.can_auth.return_value = True
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        # Auto-escalation should happen immediately because escalation time
        # is set in the past


        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'
        task.set_verifying.assert_called_with()

        mock_task.stop()

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_deny_resets_auth(self, auth, mock_task):
        '''Tests that receiving a deny from 2FA resets any saved authorization.'''
        auth.auth_status.return_value = securitybot.auth.auth.AUTH_STATES.DENIED
        auth.can_auth.return_value = True
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)

        task = mock_task.start()

        assert str(test_user._fsm.state) == 'need_task'

        test_user.add_task(task)
        test_user.step()
        assert str(test_user._fsm.state) == 'action_performed_check'

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'auth_permission_check'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        test_user.positive_response('Dummy explanation.')
        test_user.step()
        assert str(test_user._fsm.state) == 'waiting_on_auth'
        assert (test_user._last_message.answer is None and
                test_user._last_message.text == '')

        test_user.step()
        assert str(test_user._fsm.state) == 'task_finished'
        auth.reset.assert_called_with()

        mock_task.stop()

    # Auth interactions

    @patch('securitybot.tasker.tasker.Task')
    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_start_auth(self, auth, mock_task):
        '''Tests that authorization calls call the auth object.'''
        self.bot.messages = defaultdict(str)
        test_user = user.User({}, auth, self.bot)
        task = mock_task.start()

        test_user.pending_task = task
        test_user.begin_auth()
        auth.auth.assert_called_with(task.description)

        mock_task.stop()

    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_check_auth(self, auth):
        '''Tests that auth status calls interact properly.'''
        test_user = user.User({}, auth, None)

        test_user.auth_status()
        auth.auth_status.assert_called_with()

    @patch('securitybot.auth.auth.Auth', autospec=True)
    def test_reset_auth(self, auth):
        '''Tests that auth is properly reset on `reset_auth`.'''
        test_user = user.User({}, auth, None)

        test_user.reset_auth()
        auth.reset.assert_called_with()


================================================
File: /tests/state_machine_test.py
================================================
from unittest2 import TestCase

from securitybot.state_machine import StateMachine, StateMachineException

# Helper junk
class Helper(object):
    def __init__(self):
        self.x = 0

    def increment(self):
        self.x += 1

    def x_is_five(self):
        return self.x == 5

class Helper2(object):
    def __init__(self):
        self.x = 0
        self.y = 0
        self.z = 0

    def increment_x(self):
        self.x += 1

    def x_at_least_two(self):
        return self.x >= 2

    def increment_y(self):
        self.y += 5

    def increment_z(self):
        self.z += 10

class FSMTest(TestCase):
    # Functionality tests

    def test_simple_chain(self):
        '''Test most basic transition chain.'''
        states = ['one', 'two', 'three']
        transitions = [
            {'source': 'one', 'dest': 'two'},
            {'source': 'two', 'dest': 'three'},
            {'source': 'three', 'dest': 'one'},
        ]
        sm = StateMachine(states, transitions, 'one')
        assert(str(sm.state) == 'one')
        sm.step()
        assert(str(sm.state) == 'two')
        sm.step()
        assert(str(sm.state) == 'three')
        sm.step()
        assert(str(sm.state) == 'one')

    def test_simple_during(self):
        '''Tests a simple action being performed while in a state.'''
        helper = Helper()
        states = ['one', 'two']
        transitions = [
            {'source': 'one', 'dest': 'two'},
            {'source': 'two', 'dest': 'one'},
        ]
        during = {
            'one': helper.increment
        }
        sm = StateMachine(states, transitions, 'one', during=during)
        assert(helper.x == 0)
        sm.step()
        assert(helper.x == 1)
        sm.step()
        assert(helper.x == 1)

    def test_simple_on_enter(self):
        '''Tests a simple action being performed entering into a state.'''
        helper = Helper()
        states = ['one', 'two']
        transitions = [
            {'source': 'one', 'dest': 'two'},
            {'source': 'two', 'dest': 'one'},
        ]
        on_enter = {
            'two': helper.increment
        }
        sm = StateMachine(states, transitions, 'one', on_enter=on_enter)
        assert(helper.x == 0)
        sm.step()
        assert(helper.x == 1)
        sm.step()
        assert(helper.x == 1)

    def test_simple_on_exit(self):
        '''Tests a simple action being performed exiting from a state.'''
        helper = Helper()
        states = ['one', 'two']
        transitions = [
            {'source': 'one', 'dest': 'two'},
            {'source': 'two', 'dest': 'one'},
        ]
        on_exit = {
            'one': helper.increment
        }
        sm = StateMachine(states, transitions, 'one', on_exit=on_exit)
        assert(helper.x == 0)
        sm.step()
        assert(helper.x == 1)
        sm.step()
        assert(helper.x == 1)

    def test_simple_condition(self):
        '''Tests a simple condition check before transitioning.'''
        helper = Helper()
        states = ['one', 'two']
        transitions = [
            {'source': 'one', 'dest': 'two', 'condition': helper.x_is_five},
            {'source': 'two', 'dest': 'one'},
        ]
        during = {
            'one': helper.increment
        }
        sm = StateMachine(states, transitions, 'one', during=during)
        for x in range(5):
            assert(helper.x == x)
            assert(str(sm.state) == 'one')
            sm.step()
        assert(helper.x == 5)
        assert(str(sm.state) == 'two')
        sm.step()
        assert(helper.x == 5)
        assert(str(sm.state) == 'one')
        sm.step()
        assert(helper.x == 6)
        assert(str(sm.state) == 'one')
        sm.step()
        assert(helper.x == 7)
        assert(str(sm.state) == 'one')

    def test_simple_action(self):
        '''Tests a simple action being performed upon transitioning.'''
        helper = Helper()
        states = ['one', 'two']
        transitions = [
            {'source': 'one', 'dest': 'two', 'action': helper.increment},
            {'source': 'two', 'dest': 'one'}
        ]
        sm = StateMachine(states, transitions, 'one')
        assert(helper.x == 0)
        assert(str(sm.state) == 'one')
        sm.step()
        assert(helper.x == 1)
        assert(str(sm.state) == 'two')

    def test_correct_state_actions(self):
        '''
        Tests that durings, on_enters, and on_exits are called correctly and
        don't interfere with one another.
        '''
        helper = Helper2()
        states = ['one', 'two']
        transitions = [
            {'source': 'one', 'dest': 'two', 'condition': helper.x_at_least_two},
            {'source': 'two', 'dest': 'one'}
        ]
        during = {
            'one': helper.increment_x
        }
        on_enter = {
            'one': helper.increment_y
        }
        on_exit = {
            'one': helper.increment_z
        }
        sm = StateMachine(states, transitions, 'one', during=during, on_enter=on_enter,
                          on_exit=on_exit)
        sm.step()
        assert(helper.x == 1)
        assert(helper.y == 0)
        assert(helper.z == 0)
        sm.step()
        assert(helper.x == 2)
        assert(helper.y == 0)
        assert(helper.z == 10)
        sm.step()
        assert(helper.x == 2)
        assert(helper.y == 5)
        assert(helper.z == 10)

    # Invalid input error notification tests

    def test_duplicate_states(self):
        states = ['one', 'one']
        try:
            StateMachine(states, {}, 'one')
        except StateMachineException:
            return
        assert False, "No exception thrown on duplicate state names."

    def test_invalid_initial_state(self):
        try:
            StateMachine([], {}, 'foo')
        except StateMachineException:
            return
        assert False, "No exception thrown on invalid initial state name."

    def test_invalid_transition_source_name(self):
        states = ['one']
        transitions = [
            {'source': 'foo', 'dest': 'one'}
        ]
        try:
            StateMachine(states, transitions, 'one')
        except StateMachineException:
            return
        assert False, "No exception thrown on invalid transition source name."

    def test_invalid_transition_dest_name(self):
        states = ['one']
        transitions = [
            {'source': 'one', 'dest': 'foo'}
        ]
        try:
            StateMachine(states, transitions, 'one')
        except StateMachineException:
            return
        assert False, "No exception thrown on invalid transition source name."


================================================
File: /tests/util_test.py
================================================
from unittest2 import TestCase

from datetime import datetime, timedelta
import securitybot.util as util

class VarTest(TestCase):
    def test_hours(self):
        assert util.OPENING_HOUR < util.CLOSING_HOUR, 'Closing hour must be after opening hour.'

class NamedTupleTest(TestCase):
    def test_empty(self):
        tup = util.tuple_builder()
        assert tup.answer is None
        assert tup.text == ''

    def test_full(self):
        tup = util.tuple_builder(True, 'Yes')
        assert tup.answer is True
        assert tup.text == 'Yes'

class BusinessHoursTest(TestCase):
    def test_weekday(self):
        '''Test business hours during a weekday.'''
        # 18 July 2016 is a Monday. If this changes, please contact the IERS.
        morning = datetime(year=2016, month=7, day=18, hour=util.OPENING_HOUR,
                           tzinfo=util.LOCAL_TZ)
        assert util.during_business_hours(morning)
        noon = datetime(year=2016, month=7, day=18, hour=12, tzinfo=util.LOCAL_TZ)
        assert util.during_business_hours(noon), \
            'This may fail if noon is no longer during business hours.'
        afternoon = datetime(year=2016, month=7, day=18, hour=util.CLOSING_HOUR - 1,
                             minute=59, second=59, tzinfo=util.LOCAL_TZ)
        assert util.during_business_hours(afternoon)

        breakfast = datetime(year=2016, month=7, day=18, hour=util.OPENING_HOUR - 1, minute=59,
                             second=59, tzinfo=util.LOCAL_TZ)
        assert not util.during_business_hours(breakfast)
        supper = datetime(year=2016, month=7, day=18, hour=util.CLOSING_HOUR,
                          tzinfo=util.LOCAL_TZ)
        assert not util.during_business_hours(supper)

    def test_weekend(self):
        '''Test "business hours" during a weekend.'''
        # As such, 17 July 2016 is a Sunday.
        sunday_morning = datetime(year=2016, month=7, day=17, hour=util.OPENING_HOUR,
                                  tzinfo=util.LOCAL_TZ)
        assert not util.during_business_hours(sunday_morning)

class ExpirationTimeTest(TestCase):
    def test_same_day(self):
        '''Test time delta within the same day.'''
        date = datetime(year=2016, month=7, day=18, hour=util.OPENING_HOUR, tzinfo=util.LOCAL_TZ)
        td = timedelta(hours=((util.CLOSING_HOUR - util.OPENING_HOUR) % 24) / 2)
        after = date + td
        assert util.get_expiration_time(date, td) == after

    def test_next_weekday(self):
        '''Test time delta overnight.'''
        date = datetime(year=2016, month=7, day=18, hour=util.CLOSING_HOUR - 1,
                        tzinfo=util.LOCAL_TZ)
        next_date = datetime(year=2016, month=7, day=19, hour=util.OPENING_HOUR + 1,
                             tzinfo=util.LOCAL_TZ)
        assert util.get_expiration_time(date, timedelta(hours=2)) == next_date

    def test_edge_weekday(self):
        '''Test time delta overnight just barely within range.'''
        date = datetime(year=2016, month=7, day=18, hour=util.CLOSING_HOUR - 1, minute=59,
                        second=59, tzinfo=util.LOCAL_TZ)
        td = timedelta(seconds=1)
        after = datetime(year=2016, month=7, day=19, hour=util.OPENING_HOUR,
                         tzinfo=util.LOCAL_TZ)
        assert util.get_expiration_time(date, td) == after

    def test_next_weekend(self):
        '''Test time delta over a weekend.'''
        date = datetime(year=2016, month=7, day=15, hour=util.CLOSING_HOUR - 1,
                        tzinfo=util.LOCAL_TZ)
        next_date = datetime(year=2016, month=7, day=18, hour=util.OPENING_HOUR + 1,
                             tzinfo=util.LOCAL_TZ)
        assert util.get_expiration_time(date, timedelta(hours=2)) == next_date

    def test_edge_weekend(self):
        '''Test time delta over a weekend just barely within range.'''
        date = datetime(year=2016, month=7, day=15, hour=util.CLOSING_HOUR - 1, minute=59,
                        second=59, tzinfo=util.LOCAL_TZ)
        td = timedelta(seconds=1)
        after = datetime(year=2016, month=7, day=18, hour=util.OPENING_HOUR,
                         tzinfo=util.LOCAL_TZ)
        assert util.get_expiration_time(date, td) == after


================================================
File: /scripts/custom_alert.py
================================================
#!/usr/bin/python
'''
Creates a custom Securitybot alert for a specified user.
'''
import argparse
from securitybot.sql import SQLEngine
from securitybot.util import create_new_alert

from typing import Any

def main(args):
    # type: (Any) -> None
    SQLEngine('localhost', 'root', '', 'securitybot')

    create_new_alert('custom_alert', args.name[0], args.title[0], args.reason[0])

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Send a custom Securitybot alert')

    parser.add_argument('-n', '--name', dest='name', nargs=1, required=True,
                        help='Username to send alert to')
    parser.add_argument('-t', '--title', dest='title', nargs=1, required=True,
                        help='User-visible alert title')
    parser.add_argument('-r', '--reason', dest='reason', nargs=1,
                        help='Long-form reason for the alert to provided context to user.')

    args = parser.parse_args()
    main(args)


================================================
File: /scripts/query_db.py
================================================
'''
A simple script to allow querying the securitybot DB and
viewing recent alerts, mostly for debugging purposes.
'''
import argparse
import re

from securitybot.sql import SQLEngine

from typing import Any, Dict, List, Sequence

BLACKLIST_QUERY = '''
SELECT ldap
FROM blacklist
'''

IGNORED_QUERY = '''
SELECT ldap, title, reason, until
FROM ignored
'''

IGNORED_FIELDS = ['ldap', 'title', 'reason', 'until']

MAIN_QUERY = '''
SELECT HEX(alerts.hash),
       title,
       ldap,
       reason,
       description,
       splunk_url,
       comment,
       performed,
       authenticated,
       status,
       event_time
FROM alerts
JOIN user_responses ON alerts.hash = user_responses.hash
JOIN alert_status ON alerts.hash = alert_status.hash
'''

QUERY_FIELDS = ['hash',
                'title',
                'ldap',
                'reason',
                'description',
                'splunk_url',
                'comment',
                'performed',
                'authenticated',
                'status',
                'event_time']

STATUS_WHERE = 'status = %s'

PERFORMED_WHERE = 'performed = %s'

TITLE_WHERE = 'title IN ({0})'

ORDER_BY = 'ORDER BY {0}' # wow

BEFORE = 'event_time <= DATE_ADD(NOW(), INTERVAL %s HOUR)'

AFTER = 'event_time >= DATE_ADD(NOW(), INTERVAL %s HOUR)'

HAS_WHERE = False

def build_in(num_titles):
    # type: (int) -> str
    return TITLE_WHERE.format(','.join(['%s' for _ in range(num_titles)]))

LIMIT = 'LIMIT %s'

def init():
    # type: () -> None
    SQLEngine('localhost', 'root', '', 'securitybot')

def main(args):
    # type: (Any) -> None
    if args.blacklist:
        fields, matrix = blacklist(args)
    elif args.ignored:
        fields, matrix = ignored(args)
    else:
        fields, matrix = alerts(args)

    pretty_print(fields, matrix)

def blacklist(args):
    # type: (Any) -> Sequence[Any]
    fields = ['ldap']
    results = SQLEngine.execute(BLACKLIST_QUERY)
    return fields, [list(row) for row in results]

def ignored(alerts):
    # type: (Any) -> Sequence[Any]
    results = SQLEngine.execute(IGNORED_QUERY)
    return IGNORED_FIELDS, [list(row) for row in results]

def alerts(args):
    # type: (Any) -> Sequence[Any]
    params = []  # type: List[Any]
    query = MAIN_QUERY

    # Prepare for possible limited status
    if args.status is not None:
        query += build_where(STATUS_WHERE)
        params += args.status

    # Prepare for possible limited performed boolean
    if args.performed is not None:
        query += build_where(PERFORMED_WHERE)
        params += args.performed

    # Prepare for possible title restrictions
    if args.titles is not None:
        query += build_where(build_in(len(args.titles)))
        params.extend(args.titles)

    # Add time bounding
    if args.before is not None:
        query += build_where(BEFORE)
        params += [parse_time(args.before[0])]
    if args.after is not None:
        query += build_where(AFTER)
        params += [parse_time(args.after[0])]

    # Append limit restriction and order by
    query += build_order_by(args.order[0]) + '\n'
    query += LIMIT
    params += args.limit

    # Perform query
    raw_results = SQLEngine.execute(query, params)
    results = build_query_dict(raw_results)

    to_remove = [] # type: List[str]

    # Set extra fields to remove
    if args.drop is not None:
        to_remove.extend(args.drop)

    # Remove hashes if not specified
    if not args.hash:
        to_remove.append('hash')

    # Remove status if one was specified earlier
    if args.status is not None:
        to_remove.append('status')

    # Remove time if not specified
    if not args.time:
        to_remove.append('event_time')

    # Remove URL if not specified
    if not args.url:
        to_remove.append('splunk_url')

    # Anonymize if specified
    if args.anon:
        to_remove.append('ldap')

    # Remove columns
    for row in results:
        for col in to_remove:
            row.pop(col, None)

    # Grab list of fields and convert to list of lists
    fields = [field for field in QUERY_FIELDS if field not in to_remove]
    matrix = [[row[field] for field in fields] for row in results]

    return fields, matrix

def build_where(condition):
    # type: (str) -> str
    '''
    Builds another part of a where clause depending on whether any other clauses
    have been used yet. Inspects global HAS_WHERE and adds either a WHERE or AND.
    '''
    global HAS_WHERE
    s = ''
    if HAS_WHERE:
        s += 'AND'
    else:
        HAS_WHERE = True
        s += 'WHERE'
    return '{0} {1}\n'.format(s, condition)

def build_order_by(order):
    # type (str) -> str
    if order in ['event_time', 'ldap', 'title']:
        formatted = ORDER_BY.format(order)
        if order == 'event_time':
            formatted += ' DESC'
        return formatted
    raise ValueError('{0} is an invalid column to order on.'.format(order))

TIME_REGEX = re.compile(r'(-?[0-9]+)h', flags=re.IGNORECASE)

def parse_time(time):
    # type: (str) -> int
    '''
    Parses a -Xh string to an int.
    Within the code, the fact that it's negative is actually optional, but I'd rather
    not directly expose that fact.
    '''
    m = TIME_REGEX.match(time)
    if m is None:
        raise ValueError('{0} is an invalid time.'.format(time))
    return int(m.group(1))

def build_query_dict(results):
    # type: (Sequence[Sequence[Any]]) -> List[Dict[str, Any]]
    '''Builds a list of dictionaries from the results of a query.'''
    return [{field: value for field, value in zip(QUERY_FIELDS, row)} for row in results]

def pretty_print(fields, matrix):
    # type: (List[str], List[List[Any]]) -> None
    '''Pretty prints a matrix of data.'''
    contents = [fields] + matrix
    contents = [[str(i) for i in row] for row in contents]
    # Pretty print rows
    # Find maximum length for each column in the context matrix
    lens = [max([len(item) for item in col]) for col in zip(*contents)]
    # Prepare formatting string for column sizes
    fmt = ' | '.join('{{:{}}}'.format(x) for x in lens)
    # Apply formatting to each row in the context string
    table = [fmt.format(*row) for row in contents]
    # Add header separator
    table.insert(1, '-' * len(table[0]))
    # Join lines with newline
    result = '\n'.join(table)

    print result

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Explore the Securitybot DB')

    # Which table to query on -- defaults to alerts
    parser.add_argument('--blacklist', dest='blacklist', action='store_true',
                        help='Rather than query alerts, displays the blacklist.')

    parser.add_argument('--ignored', dest='ignored', action='store_true',
                        help='Rather than query alerts, displays currently ignored alerts.')

    # Alert arguments
    parser.add_argument('--titles', dest='titles', type=str, nargs='+',
                        help='One or more titles of alerts to grab.')

    parser.add_argument('-o', '--order', dest='order', type=str, default=['event_time'], nargs=1,
                        help='Name of column to order by. Must be one of event_time, ldap, title. '+
                             'Defaults to event_time.')

    parser.add_argument('-s', '--status', dest='status', type=int, nargs=1,
                        help='The status of the alerts to return. ' +
                             '0 is new, 1 is in progress, 2 is closed.')

    parser.add_argument('-p', '--performed', dest='performed', type=int, nargs=1,
                        help='0 to select alerts that the user did not perform, 1 otherwise.')

    parser.add_argument('-l', '--limit', dest='limit', type=int, default=[25], nargs=1,
                        help='The maximum number of results to return. Defaults to 25.')

    parser.add_argument('--hash', dest='hash', action='store_true',
                        help='If present, will display hash of alert.')

    parser.add_argument('-t', '--time', dest='time', action='store_true',
                        help='If present, will output time at which alert was first logged.')

    parser.add_argument('-u', '--url', dest='url', action='store_true',
                        help='If present, will output Splunk URL of alert\'s saved search.')

    parser.add_argument('-a', '--anon', dest='anon', action='store_true',
                        help='If present, will anonymize output.')

    parser.add_argument('--drop', dest='drop', type=str, nargs='+',
                        help='One or more extra fields to drop.')

    # Time bounding
    parser.add_argument('--after', dest='after', type=str, nargs=1,
                        help='Time range all alerts must be after in negative hours, e.g. -6h. ' +
                             'Note: you may have to use --after=-6h.')
    parser.add_argument('--before', dest='before', type=str, nargs=1,
                        help='Time range all alerts must be before in negative hours, e.g. -2h. ' +
                             'Note: you may have to use --before=-2h.')

    args = parser.parse_args()

    init()
    main(args)


================================================
File: /.travis.yml
================================================
language: python
python:
    - "2.7"
sudo: false
install: pip install -r requirements.txt
script:
    - flake8 --ignore F401 securitybot/
    - PYTHONPATH=$(pwd) py.test -v tests/


================================================
File: /.eslintrc.js
================================================
module.exports = {
    "env": {
        "browser": true,
        "jquery": true,
        "es6": true
    },
    "extends": "eslint:recommended",
    "rules": {
        "indent": [
            "error",
            2
        ],
        "linebreak-style": [
            "error",
            "unix"
        ],
        "quotes": [
            "error",
            "double"
        ],
        "semi": [
            "error",
            "always"
        ],
        "no-unused-vars": [
            "error",
            { "vars": "local"}
        ],
    }
};


================================================
File: /frontend/securitybot_api.py
================================================
'''
API for the Securitybot database.
'''
# Securitybot imports
from securitybot.sql import SQLEngine, SQLEngineException, init_sql
from securitybot.util import create_new_alert

# Typing
from typing import Any, Dict, List, Sequence

def init_api():
    # type: () -> None
    init_sql()

# API functions
'''
Every API call returns a JSON response through the web endpoints.
These functions themselves return dictionaries.
The generic dictionary format is as follows:
{
    "ok": [True, False]  # Whether or not the API call was successful
    "error": str         # Error from the API endpoint
    "info": str          # Additional information about the API call
    "content": Dict      # Full results from the API call.
}
The value of "content" varies on the API call.
'''

def build_response():
    # type: () -> Dict[str, Any]
    '''Builds an empty response dictionary.'''
    return {
        'ok': False,
        'error': '',
        'info': '',
        'content': {}
    }

def exception_response(e):
    res = build_response()
    res['error'] = str(e)
    return res

def build_arguments(default, args, response):
    # type: (Dict[str, Any], Dict[str, Any], Dict[str, Any]) -> None
    # Add all default arguments to args
    for arg in default:
        if arg not in args:
            args[arg] = default[arg]

    # Warn about additional arguments
    for arg in args:
        if arg not in default:
            response['info'] += 'WARNING: unknown argument {}\n'.format(arg)

def build_in(clause, num_titles):
    # type: (str, int) -> str
    return clause.format(','.join(['%s' for _ in range(num_titles)]))

def build_where(condition, has_where):
    # type: (str, bool) -> str
    '''
    Builds another part of a where clause depending on whether any other clauses
    have been used yet.
    '''
    s = 'AND' if has_where else 'WHERE'
    return '{0} {1}\n'.format(s, condition)

def build_query_dict(fields, results):
    # type: (List[str], Sequence[Sequence[Any]]) -> List[Dict[str, Any]]
    '''Builds a list of dictionaries from the results of a query.'''
    return [{field: value for field, value in zip(fields, row)} for row in results]

# Querying alerts

ALERTS_QUERY = '''
SELECT HEX(alerts.hash),
       title,
       ldap,
       reason,
       description,
       url,
       comment,
       performed,
       authenticated,
       status,
       event_time
FROM alerts
JOIN user_responses ON alerts.hash = user_responses.hash
JOIN alert_status ON alerts.hash = alert_status.hash
'''

ALERTS_FIELDS = ['hash',
                'title',
                'ldap',
                'reason',
                'description',
                'url',
                'comment',
                'performed',
                'authenticated',
                'status',
                'event_time']



STATUS_WHERE = 'status = %s'
PERFORMED_WHERE = 'performed = %s'
TITLE_IN = 'title IN ({0})'
LDAP_IN = 'ldap IN ({0})'
BEFORE = 'event_time <= FROM_UNIXTIME(%s)'
AFTER = 'event_time >= FROM_UNIXTIME(%s)'
LIMIT = 'LIMIT %s'

DEFAULT_QUERY_ARGUMENTS = {
    'limit': 50,  # max number of alerts to return
    'titles': None,  # titles of alerts to return
    'ldap': None,  # usernames of alerts to return
    'status': None,  # status of alerts to return
    'performed': None,  # performed status of alerts to return
    'authenticated': None,  # authenticated status of alerts to return
    'after': None,  # starting time of alerts to return, as a unix timestamp
    'before': None,  # ending time of alerts to return, as a unix timestamp
}

def query(**kwargs):
    # type: (**Any) -> Dict[str, Any]
    '''
    Queries the alerts database.

    Args:
        **kwargs: Arguments to the API endpoint.
    Content:
        {
            "alerts": List[Dict]: list of dictionaries representing alerts in the database
        }
        Each alert has all of the fields in QUERY_FIELDS.
    '''
    response = build_response()
    args = kwargs
    build_arguments(DEFAULT_QUERY_ARGUMENTS, args, response)

    # Build query
    query = ALERTS_QUERY
    params = [] # type: List[Any]
    has_where = False

    # Add possible where statements
    if args['status'] is not None:
        query += build_where(STATUS_WHERE, has_where)
        params.append(args['status'])
        has_where = True

    if args['performed'] is not None:
        query += build_where(PERFORMED_WHERE, has_where)
        params.append(args['performed'])
        has_where = True

    if args['titles'] is not None:
        query += build_where(build_in(TITLE_IN, len(args['titles'])), has_where)
        params.extend(args['titles'])
        has_where = True

    if args['ldap'] is not None:
        query += build_where(build_in(LDAP_IN, len(args['ldap'])), has_where)
        params.extend(args['ldap'])
        has_where = True

    # Add time bounds
    if args['before'] is not None:
        query += build_where(BEFORE, has_where)
        params.append(args['before'])
        has_where = True
    if args['after'] is not None:
        query += build_where(AFTER, has_where)
        params.append(args['after'])
        has_where = True

    # Add limit
    query += 'ORDER BY event_time DESC\n'
    query += LIMIT
    params.append(args['limit'])

    # Make SQL query
    try:
        raw_results = SQLEngine.execute(query, params)
    except SQLEngineException:
        response['error'] = 'Invalid parameters'
        return response

    results = build_query_dict(ALERTS_FIELDS, raw_results)

    # Convert datetimes to unix time
    for alert in results:
        alert['event_time'] = int(alert['event_time'].strftime('%s'))

    response['content']['alerts'] = results
    response['ok'] = True
    return response

# Querying ignored

IGNORED_QUERY = '''
SELECT ldap, title, reason, until
FROM ignored
'''

IGNORED_ORDER_BY = 'ORDER BY until DESC\n'

IGNORED_FIELDS = ['ldap', 'title', 'reason', 'until']

DEFAULT_IGNORED_ARGUMENTS = {
    'limit': 50,
    'ldap': None,
}

def ignored(**kwargs):
    # type: (**Any) -> Dict[str, Any]
    '''
    Makes a call to the ignored database.
    Content:
        {
            "ignored": List[Dict]: list of dictionaries representing ignored alerts
        }
        Each item in "ignored" has fields in IGNORED_FIELDS
    '''
    response = build_response()
    args = kwargs
    build_arguments(DEFAULT_IGNORED_ARGUMENTS, args, response)

    query = IGNORED_QUERY
    params = [] # type: List[Any]

    if args['ldap'] is not None:
        query += build_where(build_in(LDAP_IN, len(args['ldap'])), False)
        params.extend(args['ldap'])

    query += IGNORED_ORDER_BY
    query += LIMIT
    params.append(args['limit'])

    try:
        raw_results = SQLEngine.execute(query, params)
    except SQLEngineException:
        response['error'] = 'Invalid parameters'
        return response

    results = build_query_dict(IGNORED_FIELDS, raw_results)

    # Convert datetimes to timestamps
    for ignored in results:
        ignored['until'] = int(ignored['until'].strftime('%s'))

    response['content']['ignored'] = results
    response['ok'] = True
    return response

# Querying blacklist

BLACKLIST_QUERY = '''
SELECT ldap
FROM blacklist
ORDER BY ldap
LIMIT %s
'''

BLACKLIST_FIELDS = ['ldap']

DEFAULT_BLACKLIST_ARGUMENTS = {
    'limit': 50,
}

def blacklist(**kwargs):
    # type: (**Any) -> Dict[str, Any]
    '''
    Makes a call to the ignored database.
    Content:
        {
            "blacklist": List[Dict]: list of dictionaries representing ignored alerts
        }
        Each item in "blacklist" has only an ldap
    '''
    response = build_response()
    args = kwargs
    build_arguments(DEFAULT_BLACKLIST_ARGUMENTS, args, response)
    try:
        raw_results = SQLEngine.execute(BLACKLIST_QUERY, (args['limit'],))
    except SQLEngineException:
        response['error'] = 'Invalid parameters'
        return response

    results = build_query_dict(BLACKLIST_FIELDS, raw_results)

    response['content']['blacklist'] = results
    response['ok'] = True
    return response

# Custom alert creation
def create_alert(ldap, title, description, reason):
    # type: (str, str, str, str) -> Dict[str, Any]
    '''
    Creates a new alert.
    Args:
        ldap: The username of the person to send an alert to
        title: The internal title
        description: A short slug that describes the alert/user visible title
        reason: The reason for creating the alert
    Content:
        Empty.
    '''
    response = build_response()
    try:
        create_new_alert(title, ldap, description, reason)
    except SQLEngineException:
        response['error'] = 'Invalid parameters'
        return response
    response['ok'] = True
    return response


================================================
File: /frontend/securitybot_frontend.py
================================================
#!/usr/bin/env python
'''
Front-end for the Securitybot database.
'''
# Python includes
import argparse
from csv import reader
import logging
import os

# Tornado includes
import tornado.httpserver
import tornado.ioloop
import tornado.netutil
import tornado.web

# Securitybot includes
import securitybot_api as api

# Typing
from typing import Sequence

def get_endpoint(handler, defaults, callback):
    '''
    Makes a call to an API endpoint, using parameters from default.
    '''
    try:
        args = {}
        for name, default, parser in defaults:
            arg = handler.get_argument(name, default=None)
            if arg is None:
                args[name] = default
            else:
                args[name] = parser(arg)
        handler.write(callback(**args))
    except Exception as e:
        handler.write(api.exception_response(e))

# List of tuples of name, default, parser
QUERY_ARGUMENTS = [
    ('limit', 50, int),
    ('titles', None, lambda s: list(reader([s]))[0]),
    ('ldap', None, lambda s: list(reader([s]))[0]),
    ('status', None, int),
    ('performed', None, int),
    ('authenticated', None, int),
    ('after', None, int),
    ('before', None, int),
]

class QueryHandler(tornado.web.RequestHandler):
    def get(self):
        get_endpoint(self, QUERY_ARGUMENTS, api.query)

IGNORED_ARGUMENTS = [
    ('limit', 50, int),
    ('ldap', None, lambda s: list(reader([s]))[0]),
]

class IgnoredHandler(tornado.web.RequestHandler):
    def get(self):
        get_endpoint(self, IGNORED_ARGUMENTS, api.ignored)

BLACKLIST_ARGUMENTS = [
    ('limit', 50, int),
]

class BlacklistHandler(tornado.web.RequestHandler):
    def get(self):
        get_endpoint(self, BLACKLIST_ARGUMENTS, api.blacklist)

class NewAlertHandler(tornado.web.RequestHandler):
    def post(self):
        response = api.build_response()
        args = {}
        for name in ['title', 'ldap', 'description', 'reason']:
            args[name] = self.get_argument(name, default=None)
            if args[name] is None:
                response['error'] += 'ERROR: {} must be specified!\n'.format(name)
        if all(v is not None for v in args.values()):
            self.write(api.create_alert(args['ldap'],
                                        args['title'],
                                        args['description'],
                                        args['reason']))
        else:
            self.write(response)

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render()

    def render(self):
        self.write(self.render_string("templates/index.html"))

class SecuritybotService(object):
    '''Registers handlers and kicks off the HTTPServer and IOLoop'''

    def __init__(self, port):
        # type: (str, str, bool) -> None
        self.requests = 0
        self.port = port
        static_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'static/')
        self._app = tornado.web.Application([
            (r'/', IndexHandler),
            (r'/api/query', QueryHandler),
            (r'/api/ignored', IgnoredHandler),
            (r'/api/blacklist', BlacklistHandler),
            (r'/api/create', NewAlertHandler),
        ],
        xsrf_cookie=True,
        static_path=static_path,
        )
        self.server = tornado.httpserver.HTTPServer(self._app)
        self.sockets = tornado.netutil.bind_sockets(self.port, '0.0.0.0')
        self.server.add_sockets(self.sockets)
        for s in self.sockets:
            sockname = s.getsockname()
            logging.info('Listening on {socket}, port {port}'
                         .format(socket=sockname[0], port=sockname[1]))

    def start(self):
        # type: () -> None
        logging.info('Starting.')
        tornado.ioloop.IOLoop.instance().start()

    def stop(self):
        # type: () -> None
        logging.info('Stopping.')
        self.server.stop()

    def get_socket(self):
        # type: () -> Sequence[str]
        return self.sockets[0].getsockname()[:2]

def init():
    # type: () -> None
    logging.basicConfig(level=logging.DEBUG,
                        format='[%(asctime)s %(levelname)s] %(message)s')

    api.init_api()

def main(port):
    # type: (int) -> None
    logging.info('Starting up!')
    try:
        service = SecuritybotService(port)

        def shutdown():
            logging.info('Shutting down!')
            service.stop()
            logging.info('Stopped.')
            os._exit(0)

        service.start()
    except Exception as e:
        logging.error('Uncaught exception: {e}'.format(e=e))


if __name__ == '__main__':
    init()

    parser = argparse.ArgumentParser(description='Securitybot frontent')
    parser.add_argument('--port', dest='port', default='8888', type=int)
    args = parser.parse_args()

    main(args.port)


================================================
File: /frontend/templates/index.html
================================================
<html>
<head>
  <title>Securitybot front-end</title>
  <!-- Bootstrap -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js" integrity="sha384-nvAa0+6Qg9clwYCGGPpDQLVpLNn0fRaROjHqs13t4Ggj3Ez50XnGQqc/r8MhnRDZ" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
  <!-- DataTables -->
  <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/bs/dt-1.10.12/cr-1.3.2/datatables.min.css" integrity="sha384-7BhmgMfe0hg2B8/5HygrgPwzcKFOcCX6s6cbV8hNZr9W7iaAuGKSskghV4QNz123" crossorigin="anonymous"/>
  <script type="text/javascript" src="https://cdn.datatables.net/v/bs/dt-1.10.12/cr-1.3.2/datatables.min.js" integrity="sha384-fW78f6p4qkcbaOLucxJ/0dYH6CZq1S2qQWIvapIkVrpc1IaOQFspvS0IVtXiTyeF" crossorigin="anonymous"></script>
  <!-- Custom -->
  <link href="static/css/main.css" rel="stylesheet" type="text/css">
  <link href="static/favicon.ico" rel="shortcut icon">
  <script type="text/javascript" src="/static/js/main.js"></script>
</head>

<body>
  <!-- I'm bad at font-end stuff, please forgive me :( -->
  <div class="container">
    <div class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="#">Securitybot</a>
        </div>

        <div id="navbar">
          <ul class="nav navbar-nav">
            <li class="active">
              <a href="#alerts" data-toggle="tab">Alerts</a>
            </li>

            <li>
              <a href="#ignored" data-toggle="tab">Ignored</a>
            </li>

            <li>
              <a href="#blacklist" data-toggle="tab">Blacklist</a>
            </li>

            <li>
              <a href="#create" data-toggle="tab">Create</a>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <div class="alert alert-info" id="globalAlert" role="alert"></div>

    <div class="tab-content clearfix">
      <!-- DB Querying -->
      <div class="tab-pane active" id="alerts">
        <h3 class="heading">Alerts in the Securitybot database</h3>

        <form onsubmit="return submitAlerts(this);" class="form-horizontal">
          <!-- Limit -->
          <div class="form-group">
            <label for="alertsLimit" class="col-md-2 control-label">Limit</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="alertsLimit" placeholder="Limit (default: 50)">
            </div>
          </div>
          <!-- Titles -->
          <div class="form-group">
            <label for="alertsTitles" class="col-md-2 control-label">Titles</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="alertsTitles" placeholder="Titles">
            </div>
          </div>
          <!-- Ldap -->
          <div class="form-group">
            <label for="alertsLdap" class="col-md-2 control-label">Usernames</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="alertsLdap" placeholder="Usernames">
            </div>
          </div>
          <!-- Status radios -->
          <div class="form-group">
            <label for="alertsStatus" class="col-md-2 control-label">Status</label>
            <div class="col-md-10">
              <label class="radio-inline">
                <input type="radio" name="alertsStatus" id="alertsStatusAny" value="any" checked>
                Any
              </label>
              <label class="radio-inline">
                <input type="radio" name="alertsStatus" id="alertsStatusNew" value="0">
                New
              </label>
              <label class="radio-inline">
                <input type="radio" name="alertsStatus" id="alertsStatusInProgress" value="1">
                In progress
              </label>
              <label class="radio-inline">
                <input type="radio" name="alertsStatus" id="alertsStatusComplete" value="2">
                Complete
              </label>
            </div>
          </div>
          <!-- Performed radios -->
          <div class="form-group">
            <label for="alertsPerformed" class="col-md-2 control-label">Performed</label>
            <div class="col-md-10">
              <label class="radio-inline">
                <input type="radio" name="alertsPerformed" id="alertsPerformedAny" value="any" checked>
                Any
              </label>
              <label class="radio-inline">
                <input type="radio" name="alertsPerformed" id="alertsPerformedYes" value="1">
                Yes
              </label>
              <label class="radio-inline">
                <input type="radio" name="alertsPerformed" id="alertsPerformedNo" value="0">
                No
              </label>
            </div>
          </div>
          <!-- Authenticated radios -->
          <div class="form-group">
            <label for="alertsAuthenticated" class="col-md-2 control-label">Authenticated</label>
            <div class="col-md-10">
              <label class="radio-inline">
                <input type="radio" name="alertsAuthenticated" id="alertsAuthenticatedAny" value="any" checked>
                Any
              </label>
              <label class="radio-inline">
                <input type="radio" name="alertsAuthenticated" id="alertsAuthenticatedYes" value="1">
                Yes
              </label>
              <label class="radio-inline">
                <input type="radio" name="alertsAuthenticated" id="alertsAuthenticatedNo" value="0">
                No
              </label>
            </div>
          </div>
          <!-- After -->
          <div class="form-group">
            <label for="alertsAfter" class="col-md-2 control-label">Earliest alert date</label>
            <div class="col-md-10">
              <input type="datetime-local" id="alertsAfter">
            </div>
          </div>
          <!-- Before -->
          <div class="form-group">
            <label for="alertsBefore" class="col-md-2 control-label">Latest alert date</label>
            <div class="col-md-10">
              <input type="datetime-local" id="alertsBefore">
            </div>
          </div>
          <!-- Submit button -->
          <div class="form-group">
            <div class="col-md-offset-2 col-md-10">
              <button type="submit" class="btn btn-default">Search</button>
              <i class="fa fa-spinner fa-pulse fa-lg loading-icon" id="alertsLoading"></i>
            </div>
          </div>
        </form>

        <!-- Visible columns -->
        <form class="form-horizontal">
          <div class="form-group">
            <label for="visibleColumns" class="col-md-2 control-label">Visible columns</label>
            <div class="col-md-10">
              <label class="checkbox-inline">
                <input type="checkbox" name="title" parent="alerts" class="toggle-vis" checked>
                Title
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="username" parent="alerts" class="toggle-vis" checked>
                Username
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="description" parent="alerts" class="toggle-vis" checked>
                Description
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="reason" parent="alerts" class="toggle-vis" checked>
                Reason
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="performed" parent="alerts" class="toggle-vis" checked>
                Performed
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="authenticated" parent="alerts" class="toggle-vis" checked>
                Authenticated
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="url" parent="alerts" class="toggle-vis" checked>
                URL
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="status" parent="alerts" class="toggle-vis" checked>
                Status
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="event_time" parent="alerts" class="toggle-vis" checked>
                Event time
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="hash" parent="alerts" class="toggle-vis">
                Hash
              </label>
            </div>
          </div>
        </form>

        <table id="alertsTable" class="table table-hover"></table>
      </div>

      <div class="tab-pane" id="ignored">
        <h3 class="heading">Ignored alerts</h3>

        <form onsubmit="return submitIgnored(this);" class="form-horizontal">
          <!-- Limit -->
          <div class="form-group">
            <label for="ignoredLimit" class="col-md-2 control-label">Limit</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="ignoredLimit" placeholder="Limit (default: 50)">
            </div>
          </div>
          <!-- Ldap -->
          <div class="form-group">
            <label for="ignoredLdap" class="col-md-2 control-label">Usernames</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="ignoredLdap" placeholder="Usernames">
            </div>
          </div>
          <!-- Submit button -->
          <div class="form-group">
            <div class="col-md-offset-2 col-md-10">
              <button type="submit" class="btn btn-default">Search</button>
              <i class="fa fa-spinner fa-pulse fa-lg loading-icon" id="ignoredLoading"></i>
            </div>
          </div>
        </form>

        <!-- Visible columns -->
        <form class="form-horizontal">
          <div class="form-group">
            <label for="visibleColumns" class="col-md-2 control-label">Visible columns</label>
            <div class="col-md-10">
              <label class="checkbox-inline">
                <input type="checkbox" name="title" parent="ignored" class="toggle-vis" checked>
                Title
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="username" parent="ignored" class="toggle-vis" checked>
                Username
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="until" parent="ignored" class="toggle-vis" checked>
                Ignored until
              </label>

              <label class="checkbox-inline">
                <input type="checkbox" name="reason" parent="ignore" class="toggle-vis" checked>
                Reason
              </label>
            </div>
          </div>
        </form>

        <table id="ignoredTable" class="table table-hover"></table>
      </div>

      <div class="tab-pane" id="blacklist">
        <h3 class="heading">Blacklisted users</h3>

        <form onsubmit="return submitBlacklist(this);" class="form-horizontal">
          <!-- Limit -->
          <div class="form-group">
            <label for="blacklistLimit" class="col-md-2 control-label">Limit</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="blacklistLimit" placeholder="Limit (default: 50)">
            </div>
          </div>
          <!-- Submit button -->
          <div class="form-group">
            <div class="col-md-offset-2 col-md-10">
              <button type="submit" class="btn btn-default">Search</button>
              <i class="fa fa-spinner fa-pulse fa-lg loading-icon" id="blacklistLoading"></i>
            </div>
          </div>
        </form>

        <!-- Visible columns -->
        <form class="form-horizontal">
          <div class="form-group">
            <label for="visibleColumns" class="col-md-2 control-label">Visible columns</label>
            <div class="col-md-10">
              <label class="checkbox-inline">
                <input type="checkbox" name="username" parent="blacklist" class="toggle-vis" onclick="didYouReallyToggleThat(this);" checked>
                Username
              </label>
            </div>
          </div>
        </form>

        <table id="blacklistTable" class="table table-hover"></table>
      </div>

      <div class="tab-pane" id="create">
        <h3 class="heading">Send custom alert</h3>

        <form onsubmit="return submitCustom(this);" class="form-horizontal">
          <!-- Title -->
          <div class="form-group">
            <label for="customTitle" class="col-md-2 control-label">Title</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="customTitle" placeholder="Title">
            </div>
          </div>
          <!-- Ldap -->
          <div class="form-group">
            <label for="customLdap" class="col-md-2 control-label">Username</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="customLdap" placeholder="Username">
            </div>
          </div>
          <!-- Description -->
          <div class="form-group">
            <label for="customDescription" class="col-md-2 control-label">Description</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="customDescription" placeholder="Description">
            </div>
          </div>
          <!-- Reason -->
          <div class="form-group">
            <label for="customReason" class="col-md-2 control-label">Reason</label>
            <div class="col-md-10">
              <input type="text" class="form-control" id="customReason" placeholder="Reason">
            </div>
          </div>
          <!-- Submit button -->
          <div class="form-group">
            <div class="col-md-offset-2 col-md-10">
              <button type="submit" class="btn btn-default">Create</button>
              <i class="fa fa-spinner fa-pulse fa-lg loading-icon" id="customLoading"></i>
            </div>
          </div>
        </form>
    </div>
  </div>
</body>
</html>


================================================
File: /frontend/static/css/main.css
================================================
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Helvetica", "Arial", sans-serif;

  padding-top: 20px;
  padding-bottom: 20px;
}

h1, h2, h3 {
  font-weight: 300;
}

.heading {
  padding-bottom: 20px;
}

.column-selector {
  padding-top: 20px;
  padding-bottom: 20px;
}

.loading-icon {
  visibility: hidden;
}

#globalAlert {
  display: none;
}


================================================
File: /frontend/static/js/main.js
================================================
/**
 * Oh javascript, how I haven't missed you.
 * @author = Alex Bertsch
 * @email = abertsch@dropbox.com
 *
 * This is the main JavaScript source file for the Securitybot front end.
 * This should be placed _last_ in the HTML file.
 * It relies on jQuery and DataTables.
 */

function removeEmpty(obj) {
  for (let key in obj) {
    if (obj[key] === "") {
      delete obj[key];
    }
  }
}

function updateTable(id, arr) {
  let table = $(id).dataTable();
  table.fnClearTable();
  if (arr.length > 0) {
    table.fnAddData(arr);
  }
}

function setVisible(id) {
  document.getElementById(id).style.visibility = "visible";
}

function setHidden(id) {
  document.getElementById(id).style.visibility = "hidden";
}

function hideAlert() {
  document.getElementById("globalAlert").style.display = "none";
}

function showAlert() {
  document.getElementById("globalAlert").style.display = "block";
}

function presentAlert(style, message) {
  let alert = document.getElementById("globalAlert");
  showAlert();
  alert.innerHTML = message;
  alert.className = "alert " + style;
  setTimeout(hideAlert, 5000);
}

 /**
  * Submit actions for the alerts form.
  * Parses form data and sends a GET request to update the table.
  */
function submitAlerts(form) {
  // Read data from form
  // There's absolutely a better way to do this.
  let data = {};
  data["limit"] = form.alertsLimit.value;
  data["titles"] = form.alertsTitles.value;
  data["ldap"] = form.alertsLdap.value;

  data["status"] = form.querySelector("input[name=\"alertsStatus\"]:checked").value;
  data["performed"] = form.querySelector("input[name=\"alertsPerformed\"]:checked").value;
  data["authenticated"] = form.querySelector("input[name=\"alertsAuthenticated\"]:checked").value;
  // Remove "any"s
  for (let key of ["status", "performed", "authenticated"]) {
    if (data[key] === "any") {
      delete data[key];
    }
  }

  data["after"] = form.alertsAfter.value;
  data["before"] = form.alertsBefore.value;
  // Parse dates
  for (let key of ["after", "before"]) {
    if (data[key]) {
      data[key] = Date.parse(data[key]) / 1000;
    }
  }

  removeEmpty(data);

  // Use jQuery for a GET request because I'm so sorry
  setVisible("alertsLoading");
  $.get("api/query", data, updateAlerts);

  // Prevent page from updating
  return false;
}

let statuses = {
  0: "New",
  1: "In progress",
  2: "Complete",
};

/**
 * Actually update the alerts form using JSON data from an API request.
 */
function updateAlerts(data) {
  setHidden("alertsLoading");
  if (!data["ok"]) {
    presentAlert("alert-danger", "<strong>Error:</strong> " + data["error"]);
    return;
  }

  // Convert various values
  for (let alert of data["content"]["alerts"]) {
    // Timestamp => ISO string
    alert["event_time"] = new Date(parseInt(alert["event_time"]) * 1000).toISOString();

    // Status => readable string
    alert["status"] = statuses[alert["status"]];

    // Cast integers to booleans
    alert["performed"] = Boolean(alert["performed"]);
    alert["authenticated"] = Boolean(alert["authenticated"]);
  }

  updateTable("#alertsTable", data["content"]["alerts"]);
}

/**
 * Form submission handler for querying ignored alerts.
 */
function submitIgnored(form) {
  let data = {};
  data["limit"] = form.ignoredLimit.value;
  data["ldap"] = form.ignoredLdap.value;

  removeEmpty(data);

  setVisible("ignoredLoading");
  $.get("api/ignored", data, updateIgnored);

  return false;
}

/**
 * Updates the ignored table with a JSON response.
 */
function updateIgnored(data) {
  setHidden("ignoredLoading");
  if (!data["ok"]) {
    presentAlert("alert-danger", "<strong>Error:</strong> " + data["error"]);
    return;
  }

  // Convert dates to something readable
  for (let alert of data["content"]["ignored"]) {
    alert["until"] = new Date(parseInt(alert["until"]) * 1000).toISOString();
  }

  updateTable("#ignoredTable", data["content"]["ignored"]);
}

/**
 * Form submission handler for the blacklist.
 */
function submitBlacklist(form) {
  let data = {};
  data["limit"] = form.blacklistLimit.value;

  removeEmpty(data);

  setVisible("blacklistLoading");
  $.get("api/blacklist", data, updateBlacklist);

  return false;
}

/**
 * Updates the blacklist table with JSON from an API response.
 */
function updateBlacklist(data) {
  setHidden("blacklistLoading");
  if (!data["ok"]) {
    presentAlert("alert-danger", "<strong>Error:</strong> " + data["error"]);
    return;
  }

  updateTable("#blacklistTable", data["content"]["blacklist"]);
}

/**
 * Easter egg to bother use if they toggle the one column in the table.
 */
function didYouReallyToggleThat(item) {
  let box = $(item);
  if (!box.prop("checked")) {
    alert("Really?");
  }
}

/**
 * Submission call for custom alert form.
 */
function submitCustom(form) {
  let data = {};
  data["title"] = form.customTitle.value;
  data["ldap"] = form.customLdap.value;
  data["description"] = form.customDescription.value;
  data["reason"] = form.customReason.value;

  // Check for empty title or ldap
  let hasError = false;
  if (data["title"] === "") {
    form.customTitle.parentElement.parentElement.classList.add("has-error");
    hasError = true;
  } else {
    form.customTitle.parentElement.parentElement.classList.remove("has-error");
  }
  if (data["ldap"] === "") {
    form.customLdap.parentElement.parentElement.classList.add("has-error");
    hasError = true;
  } else {
    form.customLdap.parentElement.parentElement.classList.remove("has-error");
  }

  if (hasError) {
    presentAlert("alert-danger", "Please fill in the fields highlighted in red.");
  } else {
    setVisible("customLoading");
    $.post("api/create", data, validateCustom);
  }

  return false;
}

/**
 * Validate custom alert creation.
 */
function validateCustom(data) {
  setHidden("customLoading");
  if (data["ok"]) {
    presentAlert("alert-success", "<strong>Success:</strong> Alert created!");
  } else {
    presentAlert("alert-danger", "<strong>Error creating alert:</strong> " + data["error"]);
  }
}

// Page initialization
$(document).ready(function() {
  // Initialize DataTables
  let alertsTable = $("#alertsTable").DataTable({
    columns: [
      { name: "title", data: "title", title: "Title" },
      { name: "username", data: "ldap", title: "Username" },
      { name: "description", data: "description", title: "Description" },
      { name: "reason", data: "reason", title: "Reason" },
      { name: "performed", data: "performed", title: "Performed" },
      { name: "authenticated", data: "authenticated", title: "Authenticated" },
      { name: "url", data: "url", title: "URL" },
      { name: "status", data: "status", title: "Status" },
      { name: "event_time", data: "event_time", title: "Event time" },
      { name: "hash", data: "hash", title: "Hash", visible: false }
    ],
    colReorder: true,
  });

  let ignoredTable = $("#ignoredTable").DataTable({
    columns: [
      { name: "title", data: "title", title: "Title" },
      { name: "username", data: "ldap", title: "Username" },
      { name: "until", data: "until", title: "Ignored until" },
      { name: "reason", data: "reason", title: "Reason" },
    ],
    colReorder: true,
  });

  let blacklistTable = $("#blacklistTable").DataTable({
    columns: [
      { name: "username", data: "ldap", title: "Username" },
    ],
    colReorder: true,
  });

  let tables = {
    alerts: alertsTable,
    ignored: ignoredTable,
    blacklist: blacklistTable,
  };

  // Set up visibility toggles
  $(".toggle-vis").on("click", function () {
    let box = $(this);

    // Get the column API object
    let column = tables[box.attr("parent")].column(box.attr("name") + ":name");

    // Toggle column visibility
    column.visible(!column.visible());
  });
});


================================================
File: /plugins/splunk/apps/securitybot_alerts/bin/bot_lookup.py
================================================
#!/usr/local/env python
'''
Performs a MySQL query to return any events that have a SHA-256 hash matching
an event handled by the bot.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

import sys
import csv
import logging

from securitybot.sql import SQLEngine, init_sql

from typing import Any, Sequence

def find_on_hash(hash):
    # type: (str) -> Sequence[Any]
    match = SQLEngine.execute('SELECT comment, performed, authenticated FROM user_responses WHERE hash=UNHEX(%s)', (hash,))
    if len(match) != 1:
        # This catches collisions too, which is probably (hopefully) overkill
        return None
    item = match[0]
    return item[0], bool(item[1]), bool(item[2])

def main():
    # type: () -> None
    if len(sys.argv) != 5:
        print 'Usage: python bot_lookup.py [hash] [comment] [performed] [authenticated]'

    # Initialize SQL
    init_sql()

    hash_field = sys.argv[1]
    comment_field = sys.argv[2]
    performed_field = sys.argv[3]
    authenticated_field = sys.argv[4]

    infile = sys.stdin
    outfile = sys.stdout

    # Load in query from stdin
    inbound = csv.DictReader(infile)

    # Prep return CSV with the same format
    header = inbound.fieldnames
    outbound = csv.DictWriter(outfile, fieldnames=header)
    outbound.writeheader()

    for entry in inbound:
        hash = entry[hash_field]

        try:
            res = find_on_hash(hash)
            if res is not None:
                comment, performed, authenticated = res

                entry[comment_field] = comment
                entry[performed_field] = performed
                entry[authenticated_field] = authenticated
        except Exception as e:
            logging.warn('An exception was encountered making a DB call: {0}'.format(e))

        outbound.writerow(entry)

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    main()


================================================
File: /plugins/splunk/apps/securitybot_alerts/bin/send_bot_alerts.sh
================================================
#!/bin/bash
# Wrapper for send_bot_alerts.py to scrub PYTHONPATH

set -e
env -u PYTHONPATH -u LD_LIBRARY_PATH ./send_bot_alerts.py "$@" >> /var/log/securitybot/send_bot_alerts.log 2>&1


================================================
File: /plugins/splunk/apps/securitybot_alerts/bin/send_bot_alerts.py
================================================
#!/usr/local/env python

import sys
import csv
import gzip
import logging

import json

from securitybot.sql import SQLEngine, init_sql
from securitybot.util import create_new_alert

def create_securitybot_task(search_name, hash, username, description, reason, url):
    '''
    Creates a new Maniphest task with the securitybot tag so that the bot can
    reach out to the relevant people.
    '''
    logging.info('Creating new task about {} for {}'.format(description,
                                                            username))

    # Check for collision
    rows = SQLEngine.execute('SELECT title FROM alerts WHERE hash=UNHEX(%s)', (hash,))
    if rows:
        raise CollisionException(
'''We found a collision with {0} for {1}.
Most likely the Splunk alert with configured incorrectly.
However, if this is a geniune collision, then you have a paper to write. Good luck.
'''.format(rows, hash))

    # Insert that into the database as a new alert
    create_new_alert(search_name, username, description, reason, url, hash)

class CollisionException(Exception):
    pass

def send_bot_alerts(payload):
    '''
    Creates alerts for securitybot using data provided by Splunk.

    Args:
        payload (Dict[str, str]): A dictionary of parameters provided by Splunk.
    '''
    # Generic things
    results_file = payload['results_file']
    alert_name = payload['search_name']
    splunk_url = payload['results_link']

    # Action specific things
    title = payload['configuration']['title']

    try:
        with gzip.open(results_file, 'rb') as alert_file:
            reader = csv.DictReader(alert_file)
            for row in reader:
                # TODO: eventually group by username and concat event_info
                create_securitybot_task(alert_name,
                                        row['hash'],
                                        row['ldap'],
                                        title,
                                        row['event_info'],
                                        splunk_url
                )

    except Exception:
        # Can't fix anything, so just re-raise and move on
        raise

def main():
    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s %(levelname)s %(message)s')

    try:
        # Parse stdin from Splunk
        payload = json.loads(sys.stdin.read())
        logging.info('Sending bot alert: {0}'.format(payload['search_name']))

        # initialize SQL
        init_sql()

        send_bot_alerts(payload)

        logging.info('Alert {} fired successfully.\n'.format(payload['search_name']))
    except Exception as e:
        logging.error('Failure: {}'.format(e))
    logging.info('Exiting')

if __name__ == '__main__':
    main()


================================================
File: /plugins/splunk/apps/securitybot_alerts/bin/bot_lookup_launcher.py
================================================
#!/usr/bin/python
import sys
from subprocess import call

logging_file = open('/var/log/securitybot/bot_lookup.log', 'a+')
# Build arguments
c = ['env', '-u', 'PYTHONPATH', '-u', 'LD_LIBRARY_PATH', '/path/to/securitybot']
c.extend(sys.argv[1:])
call(c, stderr=logging_file)


================================================
File: /plugins/splunk/apps/securitybot_alerts/metadata/default.meta
================================================
[]
export = system


================================================
File: /plugins/splunk/apps/securitybot_alerts/default/app.conf
================================================
[ui]
is_visible = 0
label = Securitybot alert

[launcher]
author = Alex Bertsch
description = An app to send alerts to the distributed security bot.
version = 0.1

[install]
state = enabled
is_configured = 1


================================================
File: /plugins/splunk/apps/securitybot_alerts/default/alert_actions.conf
================================================
[send_bot_alerts]
is_custom = 1
label = Create Securitybot tasks
description = Configures an alert to be sent to the distributed security bot.
icon_path = securitybot.png
alert.execute.cmd = send_bot_alerts.sh
payload_format = json
disabled = 0


================================================
File: /plugins/splunk/apps/securitybot_alerts/default/data/ui/alerts/send_bot_alerts.html
================================================
<form class="form-horizontal form-complex">
  <div class="control-group">
    <label class="control-label" for="title">Alert title</label>
    <div class="controls">
      <input type="text" name="action.send_bot_alerts.param.title" id="title" />
      <span class="help-block">Title of alert when notifying user.</span>
    </div>
  </div>
</form>


================================================
File: /plugins/splunk/apps/securitybot_alerts/default/macros.conf
================================================
# Securitybot macros to make sure alerts get proper hashes
[securitybot_hashes]
definition = eval hash=sha256(_raw)

[securitybot_squash_hashes(1)]
definition = rename $hashes$ as old_hashes | eval hash=(mvindex(old_hashes), 0) | fields - old_hashes

[securitybot_responses]
definition = `securitybot_hashes` | lookup securitybot hash OUTPUT comment, performed, authenticated | fields - hash


================================================
File: /plugins/splunk/apps/securitybot_alerts/default/transforms.conf
================================================
[securitybot]
external_cmd = bot_lookup_launcher.py hash comment performed authenticated
fields_list = hash, comment, performed, authenticated


================================================
File: /plugins/splunk/README.md
================================================
## Splunk
A plugin for Splunk in the form of a custom application.
When installed, this app createes a new alerting action called "Send bot alerts" that sends alerts to Securitybot, creates a custom lookup that can find alerts from the database, and installs several macros that can be used to easily work with the bot.

### Alert actions
The "Send bot alerts" action can be added to any Splunk alert to send alerts to the bot.
However, the alert needs a little extra fine tuning before it's ready to go.
Every alert needs to output the following fields:
1. `hash`: A unique hash that identifies the alert.
2. `ldap`: The username of the user to send the alert to, ideally whoever caused the event.
3. `event_info`: A friendly explanation of what happened to be displayed to someone using the bot.
The alert action will also ask for a title field which will be displayed to the user as the title of the alert that went off.

### Macros
We have three macros that make generating hashes and later incorporating bot responses into alert rollups easier.
1. `securitybot_hashes`: Generates a `hash` field for every event.
   This should be added to a search immediately after the main search query as weird things happen otherwise.
2. `securitybot_squash_hashes(1)`: Compresses `values(hash)` or `list(hash)` into just one field.
   The parameter should be the name of the field to "squash".
   The send bot alerts alert action expects only a single hash, so we simply choose one if we've aggregated our events using `stats`.
3. `securitybot_responses`: Gather responses from bot alerts.
   When put right after the main query in a search generates fields `comment`, `performed`, and `authenticated`, which are the user's comment about an action, whether or not they performed and action, and whehter or not they successfully completed 2FA.

### Lookups
This addes the `securitybot` lookup which allows you to query the Securitybot database from within Splunk.
The fields in the lookup are `hash`, `comment`, `performed`, `authenticated`.


================================================
File: /plugins/README.md
================================================
## Securitybot plugins
This directory contains a set of plugins for various alerting and logging systems that can be used to send alerts to the bot and also look up their results later.

Each plugin probably requires some amount of tweaking to make sure that it works for your group, but otherwise most should be development-environment agnostic.


================================================
File: /securitybot/ignored_alerts.py
================================================
'''
A small file for keeping track of ignored alerts in the database.
'''
import pytz
from datetime import datetime, timedelta
from securitybot.sql import SQLEngine
from typing import Dict

def __update_ignored_list():
    # type: () -> None
    '''
    Prunes the ignored table of old ignored alerts.
    '''
    SQLEngine.execute('''DELETE FROM ignored WHERE until <= NOW()''')

def get_ignored(username):
    # type: (str) -> Dict[str, str]
    '''
    Returns a dictionary of ignored alerts to reasons why
    the ignored are ignored.

    Args:
        username (str): The username of the user to retrieve ignored alerts for.
    Returns:
        Dict[str, str]: A mapping of ignored alert titles to reasons
    '''
    __update_ignored_list()
    rows = SQLEngine.execute('''SELECT title, reason FROM ignored WHERE ldap = %s''', (username,))
    return {row[0]: row[1] for row in rows}

def ignore_task(username, title, reason, ttl):
    # type: (str, str, str, timedelta) -> None
    '''
    Adds a task with the given title to the ignore list for the given
    amount of time. Additionally adds an optional message to specify the
    reason that the alert was ignored.

    Args:
        username (str): The username of the user to ignore the given alert for.
        title (str): The title of the alert to ignore.
        ttl (Timedelta): The amount of time to ignore the alert for.
        msg (str): An optional string specifying why an alert was ignored
    '''
    expiry_time = datetime.now(tz=pytz.utc) + ttl
    # NB: Non-standard MySQL specific query
    SQLEngine.execute('''INSERT INTO ignored (ldap, title, reason, until)
    VALUES (%s, %s, %s, %s)
    ON DUPLICATE KEY UPDATE reason=VALUES(reason), until=VALUES(until)
    ''', (username, title, reason, expiry_time.strftime('%Y-%m-%d %H:%M:%S')))


================================================
File: /securitybot/auth/duo.py
================================================
'''
Authentication using Duo.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

import logging
from datetime import datetime
from urllib import urlencode
from securitybot.auth.auth import Auth, AUTH_STATES, AUTH_TIME

from typing import Any

class DuoAuth(Auth):
    def __init__(self, duo_api, username):
        # type: (Any, str) -> None
        '''
        Args:
            duo_api (duo_client.Auth): An Auth API client from Duo.
            username (str): The username of the person authorized through
                            this object.
        '''
        self.client = duo_api
        self.username = username
        self.txid = None # type: str
        self.auth_time = datetime.min
        self.state = AUTH_STATES.NONE

    def can_auth(self):
        # type: () -> bool
        # Use Duo preauth to look for a device with Push
        # TODO: This won't work for anyone who's set to auto-allow, but
        # I don't believe we have anyone like that...
        logging.debug('Checking auth capabilities for {}'.format(self.username))
        res = self.client.preauth(username=self.username)
        if res['result'] == 'auth':
            for device in res['devices']:
                if 'push' in device['capabilities']:
                    return True
        return False

    def auth(self, reason=None):
        # type: (str) -> None
        logging.debug('Sending Duo Push request for {}'.format(self.username))
        pushinfo = 'from=Securitybot'
        if reason:
            pushinfo += '&'
            pushinfo += urlencode({'reason': reason})

        res = self.client.auth(
            username=self.username,
            async=True,
            factor='push',
            device='auto',
            type='Securitybot',
            pushinfo=pushinfo
        )
        self.txid = res['txid']
        self.state = AUTH_STATES.PENDING

    def _recently_authed(self):
        # type: () -> bool
        return (datetime.now() - self.auth_time) < AUTH_TIME

    def auth_status(self):
        # type: () -> int
        if self.state == AUTH_STATES.PENDING:
            res = self.client.auth_status(self.txid)
            if not res['waiting']:
                if res['success']:
                    self.state = AUTH_STATES.AUTHORIZED
                    self.auth_time = datetime.now()
                else:
                    self.state = AUTH_STATES.DENIED
                    self.auth_time = datetime.min
        elif self.state == AUTH_STATES.AUTHORIZED:
            if not self._recently_authed():
                self.state = AUTH_STATES.NONE
        return self.state

    def reset(self):
        # type: () -> None
        self.txid = None
        self.state = AUTH_STATES.NONE


================================================
File: /securitybot/auth/auth.py
================================================
'''
An authentication object for doing 2FA on Slack users.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

from securitybot.util import enum
from datetime import timedelta
from abc import ABCMeta, abstractmethod

AUTH_STATES = enum('NONE',
                   'PENDING',
                   'AUTHORIZED',
                   'DENIED',
)

# Allowable time before 2FA is checked again.
# Ideally this should be as low as possible without being annoying.
AUTH_TIME = timedelta(hours=2)

class Auth(object):
    '''
    When designing Auth subclasses, try to make sure that the authorization
    attempt is as non-blocking as possible.
    '''
    __metaclass__ = ABCMeta

    @abstractmethod
    def can_auth(self):
        # type: () -> bool
        '''
        Returns:
            (bool) Whether 2FA is available.
        '''
        pass

    @abstractmethod
    def auth(self, reason=None):
        # type: (str) -> None
        '''
        Begins an authorization request, which should be non-blocking.

        Args:
            reason (str): Optional reason string that may be provided
        '''
        pass

    @abstractmethod
    def auth_status(self):
        # type: () -> int
        '''
        Returns:
            (enum) The current auth status, one of AUTH_STATES.
        '''
        pass

    @abstractmethod
    def reset(self):
        # type: () -> None
        '''
        Resets auth status.
        '''
        pass


================================================
File: /securitybot/commands.py
================================================
'''
File for securitybot commands.

Each command function takes a user and arguments as its arguments.
It also has `bot`, a reference to the bot that called it.
They return True upon success and False upon failure, or just None
if the command doesn't have success/failure messages.
'''
import re

from datetime import timedelta

import securitybot.ignored_alerts as ignored_alerts
from securitybot.util import create_new_alert

def hi(bot, user, args):
    '''Says hello to a user.'''
    bot.chat.message_user(user, bot.messages['hi'].format(user.get_name()))

def help(bot, user, args):
    '''Prints help for each command.'''
    msg = '{0}\n\n'.format(bot.messages['help_header'])
    for name, info in sorted(bot.commands.items()):
        if not info['hidden'] or '-a' in args:
            msg += '`{0}`: {1}\n'.format(name, info['info'])
            if info['usage']:
                usage_str = '\n'.join(['> \t' + s for s in info['usage']])
                msg += '> {0}:\n{1}\n'.format(bot.messages['help_usage'], usage_str)
    msg += bot.messages['help_footer']
    bot.chat.message_user(user, msg)

def add_to_blacklist(bot, user, args):
    '''Adds a user to the blacklist.'''
    name = user['name']
    if not bot.blacklist.is_present(name):
        bot.blacklist.add(name)
        return True
    return False

def remove_from_blacklist(bot, user, args):
    '''Removes a user from the blacklist.'''
    name = user['name']
    if bot.blacklist.is_present(name):
        bot.blacklist.remove(name)
        return True
    return False

def positive_response(bot, user, args):
    '''Registers a postive response from a user.'''
    user.positive_response(' '.join(args))

def negative_response(bot, user, args):
    '''Registers a negative response from a user.'''
    user.negative_response(' '.join(args))

TIME_REGEX = re.compile(r'([0-9]+h)?([0-9]+m)?', flags=re.IGNORECASE)
OUTATIME = timedelta()
TIME_LIMIT = timedelta(hours=4)

def ignore(bot, user, args):
    '''Ignores a specific alert for a user for some period of time.'''
    if len(args) != 2:
        return False

    which, time = args

    # Find correct task in user object
    task = None
    if which == 'last' and user.tasks:
        task = user.tasks[-1]
    elif which == 'current' and user.pending_task:
        task = user.pending_task
    if task is None:
        return False

    # Parse given time using above regex
    match = TIME_REGEX.match(time)
    if not (match or match.group(0)):
        return False
    # Parse time returned by regex, snipping off the trailing letter
    hours = int(match.group(1)[:-1]) if match.group(1) else 0
    minutes = int(match.group(2)[:-1]) if match.group(2) else 0
    # Build and cap time if needed
    ignoretime = timedelta(hours=hours, minutes=minutes)
    if ignoretime > TIME_LIMIT:
        bot.chat.message_user(user, bot.messages['ignore_time'])
        ignoretime = TIME_LIMIT
    elif ignoretime <= OUTATIME:
        bot.chat.message_user(user, bot.messages['ignore_no_time'])
        return False

    ignored_alerts.ignore_task(user['name'], task.title, 'ignored', ignoretime)
    return True

def test(bot, user, args):
    '''Creates a new test alert in Maniphest for a user.'''
    create_new_alert('testing_alert', user['name'], 'Testing alert', 'Testing Securitybot')

    return True


================================================
File: /securitybot/state_machine.py
================================================
'''
A simple FSM for controlling user state.
You know, as opposed to all those state machines that _don't_ manage state.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

import logging
from collections import defaultdict

from typing import Callable

class StateMachine(object):
    '''
    A minimal state machine with the ability to declare state transition
    conditions, functions to call when entering and exiting any state, and
    functions to call while in any particular state. All of this is done
    through a single `step` function, which performs all tasks and potentially
    advances to the next state if a condition is met.

    Essentially, this state machine is "eager", it always wants to transition
    to the next state if possible. You could make a main loop out of simply
    chaining state together with various conditions, but this would probably
    make for a terrible UI state machine.
    '''

    def __init__(self, states, transitions, initial, during=None, on_enter=None,
                 on_exit=None):
        '''
        Creates a new state machine. The `during`, `on_enter`, and `on_exit`
        dictionaries are all optional. Additionally, each is free to have
        as few or as many of each state as desired, i.e. leaving out states
        is fine.
        Args:
            states (List[str]): A list of all possible states in the FSM.
            transitions (List[Dict[str, function]]): Dictionaries of transitions
                and conditions. Each dictionary must contain the following keys:
                    source (str): The source state of the transition.
                    dest (str): The destination state of the transition.
                Each dictionary may contain the following keys:
                    condition (function): A condition that must be true for the
                        transition to occur. If no condition is provided then the
                        state machine will transition on a step.
                    action (function): A function to be executed while the
                        transition occurs.
            during (Dict[str, function]): A mapping of states to functions to
                execute while in that state.
            initial (str): The state to start in.
            on_enter (Dict[str, function]): A mapping of states to functions to
                execute when entering that state.
            on_exit (Dict[str, function]): A mapping of states to functions to
                execute when exiting from that state.
        '''
        if during is None:
            during = {}
        if on_enter is None:
            on_enter = {}
        if on_exit is None:
            on_exit = {}

        # Build states
        if sorted(list(set(states))) != sorted(states):
            raise StateMachineException('Duplicate state names encountered:\n{0}'.format(states))

        self._states = {}
        for state in states:
            self._states[state] = State(state,
                                        during.get(state, None),
                                        on_enter.get(state, None),
                                        on_exit.get(state, None)
                                        )

        # Set initial state
        if initial not in self._states:
            raise StateMachineException('Invalid initial state: {0}'.format(initial))
        self.state = self._states[initial]

        # Build transitions
        self._transitions = defaultdict(list)
        for transition in transitions:
            # Validate transition for correct states
            if transition['source'] not in self._states:
                raise StateMachineException('Invalid source state: {0}'
                    .format(transition['source']))
            if transition['dest'] not in self._states:
                raise StateMachineException('Invalid destination state: {0}'
                    .format(transition['dest']))

            source_state = self._states[transition['source']]
            dest_state = self._states[transition['dest']]
            self._transitions[transition['source']].append(Transition(source_state,
                                                               dest_state,
                                                               transition.get('condition', None),
                                                               transition.get('action', None)
                                                               ))

    def step(self):
        # type: () -> None
        '''
        Performs a step in the state machine.
        Each step iterates over the current state's `during` function then checks all
        possible transition paths, evaluates their condition, and transitions if possible.
        The next state is which transition condition was true first or the current state
        if no conditions were true.
        '''
        self.state.during()

        for transition in self._transitions[self.state.name]:
            if transition.condition():
                logging.debug('Transitioning: {0}'.format(transition))
                transition.action()
                self.state.on_exit()
                self.state = transition.dest
                self.state.on_enter()
                break

class State(object):
    '''
    A simple representation of a state in `StateMachine`.
    Each state has a function to perform while it's active, when it's entered
    into, and when it's exited. These functions may be None.
    '''
    def __init__(self, name, during, on_enter, on_exit):
        # type: (str, Callable[..., None], Callable[..., None], Callable[..., None]) -> None
        '''
        Args:
            name (str): The name of this state.
            during (function): A function to call while this state is active.
            on_enter (function): A function to call when transitioning into
                                 this state.
            on_exit (function): A function to call when transitioning out of
                                this state.
        '''
        self.name = name
        self._during = during
        self._on_enter = on_enter
        self._on_exit = on_exit

    def __repr__(self):
        # type: () -> str
        return "State({0}, {1}, {2}, {3})".format(self.name,
                                                  self._during,
                                                  self._on_enter,
                                                  self._on_exit
                                                  )

    def __str__(self):
        # type: () -> str
        return self.name

    def during(self):
        # type: () -> None
        if self._during is not None:
            self._during()

    def on_enter(self):
        # type: () -> None
        if self._on_enter is not None:
            self._on_enter()

    def on_exit(self):
        # type: () -> None
        if self._on_exit is not None:
            self._on_exit()

class Transition(object):
    '''
    A transition object to move between states. Each transition object holds
    a reference to its source and destination states, as well as the condition
    function it requires for transitioning and the action to perform upon
    transitioning.
    '''

    def __init__(self, source, dest, condition, action):
        # type: (State, State, Callable[..., bool], Callable[..., None]) -> None
        '''
        Args:
            source (State): The source State for this transition.
            dest (State): The destination State for this transition.
            condition (function): The transitioning condition callback.
            action (function): An action to perform upon transitioning.
        '''
        self.source = source
        self.dest = dest
        self._condition = condition
        self._action = action

    def __repr__(self):
        # type: () -> str
        return "Transition({0}, {1}, {2}, {3})".format(repr(self.source),
                                                       repr(self.dest),
                                                       self._condition,
                                                       self._action
                                                       )

    def __str__(self):
        # type: () -> str
        return "{0} => {1}".format(self.source, self.dest)

    def condition(self):
        # type: () -> bool
        # Conditions default to True if none is provided
        return True if self._condition is None else self._condition()

    def action(self):
        # type: () -> None
        if self._action is not None:
            self._action()

class StateMachineException(Exception):
    pass


================================================
File: /securitybot/blacklist/sql_blacklist.py
================================================
'''
A MySQL-based blacklist class.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

from securitybot.blacklist.blacklist import Blacklist
from securitybot.sql import SQLEngine

class SQLBlacklist(Blacklist):
    def __init__(self):
        # type: () -> None
        '''
        Creates a new blacklist tied to a table named "blacklist".
        '''
        # Load from table
        names = SQLEngine.execute('SELECT * FROM blacklist')
        # Break tuples into names
        self._blacklist = {name[0] for name in names}

    def is_present(self, name):
        # type: (str) -> bool
        '''
        Checks if a name is on the blacklist.

        Args:
            name (str): The name to check.
        '''
        return name in self._blacklist

    def add(self, name):
        # type: (str) -> None
        '''
        Adds a name to the blacklist.

        Args:
            name (str): The name to add to the blacklist.
        '''
        self._blacklist.add(name)
        SQLEngine.execute('INSERT INTO blacklist (ldap) VALUES (%s)', (name,))

    def remove(self, name):
        # type: (str) -> None
        '''
        Removes a name to the blacklist.

        Args:
            name (str): The name to remove from the blacklist.
        '''
        self._blacklist.remove(name)
        SQLEngine.execute('DELETE FROM blacklist WHERE ldap = %s', (name,))


================================================
File: /securitybot/blacklist/blacklist.py
================================================
'''
A generic blacklist class.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

from abc import ABCMeta, abstractmethod

class Blacklist(object):
    __metaclass__ = ABCMeta

    @abstractmethod
    def is_present(self, name):
        # type: (str) -> bool
        '''
        Checks if a name is on the blacklist.

        Args:
            name (str): The name to check.
        '''
        pass

    @abstractmethod
    def add(self, name):
        # type: (str) -> None
        '''
        Adds a name to the blacklist.

        Args:
            name (str): The name to add to the blacklist.
        '''
        pass

    @abstractmethod
    def remove(self, name):
        # type: (str) -> None
        '''
        Removes a name to the blacklist.

        Args:
            name (str): The name to remove from the blacklist.
        '''
        pass


================================================
File: /securitybot/tasker/tasker.py
================================================
'''
A system for retrieving and assigning tasks for the bot as well as updating
their statuses once acted up. This file contains two abstract classes,
Tasker and Task, which define a class to manage tasks and a task class
respectively.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

from abc import ABCMeta, abstractmethod
from securitybot.util import enum

class Tasker(object):
    '''
    A simple interface to retrieve tasks on which the bot should act upon.
    '''
    __metaclass__ = ABCMeta

    @abstractmethod
    def get_new_tasks(self):
        # type: () -> List[Task]
        '''
        Returns a list of new Task objects that need to be acted upon, i.e.
        the intial message needs to be sent out to the alertee.
        '''
        pass

    @abstractmethod
    def get_active_tasks(self):
        # type: () -> List[Task]
        '''
        Returns a list of Task objects for which the alertees have been
        contacted but have not replied. Periodically this list should be polled
        and stale tasks should have their alertees pinged.
        '''
        pass

    @abstractmethod
    def get_pending_tasks(self):
        # type: () -> List[Task]
        '''
        Retrieves a list of tasks for which the user has responded and it now
        waiting for manual closure.
        '''
        pass

# Task status levels
STATUS_LEVELS = enum('OPEN', 'INPROGRESS', 'VERIFICATION')

class Task(object):
    __metaclass__ = ABCMeta

    def __init__(self, title, username, reason, description, url, performed, comment,
            authenticated, status):
        # type: (str, str, str, str, str, bool, str, bool, int) -> None
        '''
        Creates a new Task for an alert that should go to `username` and is
        currently set to `status`.

        Args:
            title (str): The title of this task.
            username (str): The user who should be alerted from the Task.
            reason (str): The reason that the alert was fired.
            description (str): A description of the alert in question.
            url (str): A URL in which more information can be found about the
                       alert itself, not the Task.
            performed (bool): Whether or not the user performed the action that
                              caused this alert.
            comment (str): The user's comment on why the action occured.
            authenticated (bool): Whether 2FA has suceeded.
            status (enum): See `STATUS_LEVELS` from above.
        '''
        self.title = title
        self.username = username
        self.reason = reason
        self.description = description
        self.url = url
        self.performed = performed
        self.comment = comment
        self.authenticated = authenticated
        self.status = status

    @abstractmethod
    def set_open(self):
        # type: () -> None
        '''
        Sets this task to be open and performs any needed actions to ensure that
        the corresponding tasker will be able to properly see it as such.
        '''
        pass

    @abstractmethod
    def set_in_progress(self):
        # type: () -> None
        '''
        Sets this task to be in progress and performs any needed actions to
        ensure the corresponding tasker will be able to see it as such.
        '''
        pass

    @abstractmethod
    def set_verifying(self):
        # type: () -> None
        '''
        Sets this task to be waiting for verification and performs and needed
        actions to ensure that the corresponding tasker sees it as such.
        '''
        pass


================================================
File: /securitybot/tasker/sql_tasker.py
================================================
'''
A tasker on top of a SQL database.
'''
from securitybot.tasker.tasker import Task, Tasker, STATUS_LEVELS
from securitybot.sql import SQLEngine

from typing import List

# Note: this order is provided to match the SQLTask constructor
GET_ALERTS = '''
SELECT HEX(alerts.hash),
       title,
       ldap,
       reason,
       description,
       url,
       performed,
       comment,
       authenticated,
       status
FROM alerts
JOIN user_responses ON alerts.hash = user_responses.hash
JOIN alert_status ON alerts.hash = alert_status.hash
WHERE status = %s
'''

class SQLTasker(Tasker):
    def _get_tasks(self, level):
        # type: (int) -> List[Task]
        '''
        Gets all tasks of a certain level.

        Args:
            level (int): One of STATUS_LEVELS
        Returns:
            List of SQLTasks.
        '''
        alerts = SQLEngine.execute(GET_ALERTS, (level,))
        return [SQLTask(*alert) for alert in alerts]

    def get_new_tasks(self):
        # type: () -> List[Task]
        return self._get_tasks(STATUS_LEVELS.OPEN)


    def get_active_tasks(self):
        # type: () -> List[Task]
        return self._get_tasks(STATUS_LEVELS.INPROGRESS)

    def get_pending_tasks(self):
        # type: () -> List[Task]
        return self._get_tasks(STATUS_LEVELS.VERIFICATION)

SET_STATUS = '''
UPDATE alert_status
SET status=%s
WHERE hash=UNHEX(%s)
'''

SET_RESPONSE = '''
UPDATE user_responses
SET comment=%s,
    performed=%s,
    authenticated=%s
WHERE hash=UNHEX(%s)
'''

class SQLTask(Task):
    def __init__(self, hsh, title, username, reason, description, url,
                 performed, comment, authenticated, status):
        # type: (str, str, str, str, str, str, bool, str, bool, int) -> None
        '''
        Args:
            hsh (str): SHA256 primary key hash.
        '''
        super(SQLTask, self).__init__(title, username, reason, description, url,
                                   performed, comment, authenticated, status)
        self.hash = hsh

    def _set_status(self, status):
        # type: (int) -> None
        '''
        Sets the status of a task in the DB.

        Args:
            status (int): The new status to use.
        '''
        SQLEngine.execute(SET_STATUS, (status, self.hash))

    def _set_response(self):
        # type: () -> None
        '''
        Updates the user response for this task.
        '''
        SQLEngine.execute(SET_RESPONSE, (self.comment,
                                         self.performed,
                                         self.authenticated,
                                         self.hash))

    def set_open(self):
        self._set_status(STATUS_LEVELS.OPEN)

    def set_in_progress(self):
        self._set_status(STATUS_LEVELS.INPROGRESS)

    def set_verifying(self):
        self._set_status(STATUS_LEVELS.VERIFICATION)
        self._set_response()


================================================
File: /securitybot/chat/chat.py
================================================
'''
A simple wrapper over an abstract chat/messaging system
like Slack.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

from securitybot.user import User
from abc import ABCMeta, abstractmethod

from typing import Any, Dict, List

class Chat(object):
    '''
    A wrapper over various chat frameworks, like Slack.
    '''
    __metaclass__ = ABCMeta

    @abstractmethod
    def connect(self):
        # type: () -> None
        '''Connects to the chat system.'''
        pass

    @abstractmethod
    def get_users(self):
        # type: () -> List[Dict[str, Any]]
        '''
        Returns a list of all users in the chat system.

        Returns:
            A list of dictionaries, each dictionary representing a user.
            The rest of the bot expects the following minimal format:
            {
                "name": The username of a user,
                "id": A user's unique ID in the chat system,
                "profile": A dictionary representing a user with at least:
                    {
                        "first_name": A user's first name
                    }
            }
        '''
        pass

    @abstractmethod
    def get_messages(self):
        # type () -> List[Dict[str, Any]]
        '''
        Gets a list of all new messages received by the bot in direct
        messaging channels. That is, this function ignores all messages
        posted in group chats as the bot never interacts with those.

        Each message should have the following format, minimally:
        {
            "user": The unique ID of the user who sent a message.
            "text": The text of the received message.
        }
        '''
        pass

    @abstractmethod
    def send_message(self, channel, message):
        # type: (Any, str) -> None
        '''
        Sends some message to a desired channel.
        As channels are possibly chat-system specific, this function has a horrible
        type signature.
        '''
        pass

    @abstractmethod
    def message_user(self, user, message):
        # type: (User, str) -> None
        '''
        Sends some message to a desired user, using a User object and a string message.
        '''
        pass

class ChatException(Exception):
    pass


================================================
File: /securitybot/chat/slack.py
================================================
'''
A wrapper over the Slack API.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

import logging
from slackclient import SlackClient
import json

from securitybot.user import User
from securitybot.chat.chat import Chat, ChatException

from typing import Any, Dict, List

class Slack(Chat):
    '''
    A wrapper around the Slack API designed for Securitybot.
    '''
    def __init__(self, username, token, icon_url):
        # type: (str, str, str) -> None
        '''
        Constructs the Slack API object using the bot's username, a Slack
        token, and a URL to what the bot's profile pic should be.
        '''
        self._username = username
        self._icon_url = icon_url

        self._slack = SlackClient(token)
        self._validate()

    def _validate(self):
        # type: () -> None
        '''Validates Slack API connection.'''
        response = self._api_call('api.test')
        if not response['ok']:
            raise ChatException('Unable to connect to Slack API.')
        logging.info('Connection to Slack API successful!')

    def _api_call(self, method, **kwargs):
        # type: (str, **Any) -> Dict[str, Any]
        '''
        Performs a _validated_ Slack API call. After performing a normal API
        call using SlackClient, validate that the call returned 'ok'. If not,
        log and error.

        Args:
            method (str): The API endpoint to call.
            **kwargs: Any arguments to pass on to the request.
        Returns:
            (dict): Parsed JSON from the response.
        '''
        response = self._slack.api_call(method, **kwargs)
        if not ('ok' in response and response['ok']):
            if kwargs:
                logging.error('Bad Slack API request on {} with {}'.format(method, kwargs))
            else:
                logging.error('Bad Slack API request on {}'.format(method))
        return response

    def connect(self):
        # type: () -> None
        '''Connects to the chat system.'''
        logging.info('Attempting to start Slack RTM session.')
        if self._slack.rtm_connect():
            logging.info('Slack RTM connection successful.')
        else:
            raise ChatException('Unable to start Slack RTM session')

    def get_users(self):
        # type: () -> List[Dict[str, Any]]
        '''
        Returns a list of all users in the chat system.

        Returns:
            A list of dictionaries, each dictionary representing a user.
            The rest of the bot expects the following minimal format:
            {
                "name": The username of a user,
                "id": A user's unique ID in the chat system,
                "profile": A dictionary representing a user with at least:
                    {
                        "first_name": A user's first name
                    }
            }
        '''
        return self._api_call('users.list')['members']

    def get_messages(self):
        # type () -> List[Dict[str, Any]]
        '''
        Gets a list of all new messages received by the bot in direct
        messaging channels. That is, this function ignores all messages
        posted in group chats as the bot never interacts with those.

        Each message should have the following format, minimally:
        {
            "user": The unique ID of the user who sent a message.
            "text": The text of the received message.
        }
        '''
        events = self._slack.rtm_read()
        messages = [e for e in events if e['type'] == 'message']
        return [m for m in messages if 'user' in m and m['channel'].startswith('D')]

    def send_message(self, channel, message):
        # type: (Any, str) -> None
        '''
        Sends some message to a desired channel.
        As channels are possibly chat-system specific, this function has a horrible
        type signature.
        '''
        self._api_call('chat.postMessage', channel=channel,
                                           text=message,
                                           username=self._username,
                                           as_user=False,
                                           icon_url=self._icon_url)

    def message_user(self, user, message):
        # type: (User, str) -> None
        '''
        Sends some message to a desired user, using a User object and a string message.
        '''
        channel = self._api_call('im.open', user=user['id'])['channel']['id']
        self.send_message(channel, message)


================================================
File: /securitybot/bot.py
================================================
'''
The internals of securitybot. Defines a core class SecurityBot that manages
most of the bot's behavior.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

import logging
from securitybot.user import User
import time
from datetime import datetime, timedelta
import pytz
import shlex
import yaml
import string

import securitybot.commands as bot_commands
from securitybot.blacklist.sql_blacklist import SQLBlacklist
from securitybot.chat.chat import Chat
from securitybot.tasker.tasker import Task, Tasker
from securitybot.auth.auth import Auth

from typing import Any, Callable, Dict, List, Tuple

TASK_POLL_TIME = timedelta(minutes=1)
REPORTING_TIME = timedelta(hours=1)

DEFAULT_COMMAND = {
    'fn': lambda b, u, a: logging.warn('No function provided for this command.'),
    'info': 'I was too lazy to provide information for this command',
    'hidden': False,
    'usage': None,
    'success_msg': None,
    'failure_msg': None,
}

def clean_input(text):
    # type: (unicode) -> str
    '''
    Cleans some input text, doing things such as removing smart quotes.
    '''
    # Replaces smart quotes; Shlex crashes if it encounters an unbalanced
    # smart quote, as happens with auto-formatting.
    text = (text.replace(u'\u2018', '\'')
                .replace(u'\u2019', '\'')
                .replace(u'\u201c','"')
                .replace(u'\u201d', '"'))
    # Undo autoformatting of dashes
    text = (text.replace(u'\u2013', '--')
                .replace(u'\u2014', '--'))

    return text.encode('utf-8')

PUNCTUATION = '.,!?\'"`'

def clean_command(command):
    # type: (str) -> str
    '''Cleans a command.'''
    command = command.lower()
    # Force to str
    command = command.encode('utf-8')
    # Remove punctuation people are likely to use and won't interfere with command names
    command = command.translate(string.maketrans('', ''), PUNCTUATION)
    return command

class SecurityBot(object):
    '''
    It's always dangerous naming classes the same name as the project...
    '''

    def __init__(self, chat, tasker, auth_builder, reporting_channel, config_path):
        # type: (Chat, Tasker, Callable[[str], Auth], str, str) -> None
        '''
        Args:
            chat (Chat): The chat object to use for messaging.
            tasker (Tasker): The Tasker object to get tasks from
            auth_builder (Auth): The constructor to build Auth objects from.
                                 It should take in only a username as a parameter.
            reporting_channel (str): Channel ID to report alerts in need of verification to.
            config_path (str): Path to configuration file
        '''
        logging.info('Creating securitybot.')
        self.tasker = tasker
        self.auth_builder = auth_builder
        self.reporting_channel = reporting_channel
        self._last_task_poll = datetime.min.replace(tzinfo=pytz.utc)
        self._last_report = datetime.min.replace(tzinfo=pytz.utc)

        self._load_config(config_path)

        self.chat = chat
        chat.connect()

        # Load blacklist from SQL
        self.blacklist = SQLBlacklist()

        # A dictionary to be populated with all members of the team
        self.users = {} # type: Dict[str, User]
        self.users_by_name = {} # type: Dict[str, User]
        self._populate_users()

        # Dictionary of users who have outstanding tasks
        self.active_users = {} # type: Dict[str, User]

        # Recover tasks
        self.recover_in_progress_tasks()

        logging.info('Done!')

    # Initialization functions

    def _load_config(self, config_path):
        # type: (str) -> None
        '''
        Loads a configuration file for the bot.
        '''
        logging.info('Loading configuration.')
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)

            # Required parameters
            try:
                self._load_messages(config['messages_path'])
                self._load_commands(config['commands_path'])
            except KeyError as e:
                logging.error('Missing parameter: {0}'.format(e))
                raise SecurityBotException('Configuration file missing parameters.')

            # Optional parameters
            self.icon_url = config.get('icon_url', 'https://placehold.it/256x256')

    def _load_messages(self, messages_path):
        # type: (str) -> None
        '''
        Loads messages from a YAML file.

        Args:
            messages_path (str): Path to messages file.
        '''
        self.messages = yaml.safe_load(open(messages_path))

    def _load_commands(self, commands_path):
        # type: (str) -> None
        '''
        Loads commands from a configuration file.

        Args:
            commands_path (str): Path to commands file.
        '''
        with open(commands_path, 'r') as f:
            commands = yaml.safe_load(f)

            self.commands = {} # type: Dict[str, Any]
            for name, cmd in commands.items():
                new_cmd = DEFAULT_COMMAND.copy()
                new_cmd.update(cmd)

                try:
                    new_cmd['fn'] = getattr(bot_commands, format(cmd['fn']))
                except AttributeError as e:
                    raise SecurityBotException('Invalid function: {0}'.format(e))

                self.commands[name] = new_cmd
        logging.info('Loaded commands: {0}'.format(self.commands.keys()))

    # Bot functions

    def run(self):
        # type: () -> None
        '''
        Main loop for the bot.
        '''
        while True:
            now = datetime.now(tz=pytz.utc)
            if now - self._last_task_poll > TASK_POLL_TIME:
                self._last_task_poll = now
                self.handle_new_tasks()
                self.handle_in_progress_tasks()
                self.handle_verifying_tasks()
            self.handle_messages()
            self.handle_users()
            time.sleep(.1)

    def handle_messages(self):
        # type: () -> None
        '''
        Handles all messages sent to securitybot.
        Currently only active users are considered, i.e. we don't care if a user
        sends us a message but we haven't sent them anything.
        '''
        messages = self.chat.get_messages()
        for message in messages:
            user_id = message['user']
            text = message['text']
            user = self.user_lookup(user_id)

            # Parse each received line as a command, otherwise send an error message
            if self.is_command(text):
                self.handle_command(user, text)
            else:
                self.chat.message_user(user, self.messages['bad_command'])

    def handle_command(self, user, command):
        # type: (User, str) -> None
        '''
        Handles a given command from a user.
        '''
        key, args = self.parse_command(command)
        logging.info('Handling command {0} for {1}'.format(key, user['name']))
        cmd = self.commands[key]
        if cmd['fn'](self, user, args):
            if cmd['success_msg']:
                self.chat.message_user(user, cmd['success_msg'])
        else:
            if cmd['failure_msg']:
                self.chat.message_user(user, cmd['failure_msg'])

    def valid_user(self, username):
        # type: (str) -> bool
        '''
        Validates a username to be valid.
        '''
        if len(username.split()) != 1:
            return False
        try:
            self.user_lookup_by_name(username)
            return True
        except SecurityBotException as e:
            logging.warn('{}'.format(e))
            return False

    def _add_task(self, task):
        # type: (Task) -> None
        '''
        Adds a new task to the user specified by that task.

        Args:
            task (Task): the task to add.
        '''
        username = task.username
        if self.valid_user(username):
            # Ignore blacklisted users
            if self.blacklist.is_present(username):
                logging.info('Ignoring task for blacklisted {0}'.format(username))
                task.comment = 'blacklisted'
                task.set_verifying()
            else:
                user = self.user_lookup_by_name(username)
                user_id = user['id']
                if user_id not in self.active_users:
                    logging.debug('Adding {} to active users'.format(username))
                    self.active_users[user_id] = user
                    self.greet_user(user)
                user.add_task(task)
                task.set_in_progress()
        else:
            # Escalate if no valid user is found
            logging.warn('Invalid user: {0}'.format(username))
            task.comment = 'invalid user'
            task.set_verifying()

    def handle_new_tasks(self):
        # type: () -> None
        '''
        Handles all new tasks.
        '''
        for task in self.tasker.get_new_tasks():
            # Log new task
            logging.info('Handling new task for {0}'.format(task.username))

            self._add_task(task)

    def handle_in_progress_tasks(self):
        # type: () -> None
        '''
        Handles all in progress tasks.
        '''
        pass

    def recover_in_progress_tasks(self):
        # type: () -> None
        '''
        Recovers in progress tasks from a previous run.
        '''
        for task in self.tasker.get_active_tasks():
            # Log new task
            logging.info('Recovering task for {0}'.format(task.username))

            self._add_task(task)


    def handle_verifying_tasks(self):
        # type: () -> None
        '''
        Handles all tasks which are currently waiting for verification.
        '''
        pass

    def handle_users(self):
        # type: () -> None
        '''
        Handles all users.
        '''
        for user_id in self.active_users.keys():
            user = self.active_users[user_id]
            user.step()

    def cleanup_user(self, user):
        # type: (User) -> None
        '''
        Cleanup a user from the active users list once they have no remaining
        tasks.
        '''
        logging.debug('Removing {} from active users'.format(user['name']))
        self.active_users.pop(user['id'], None)

    def alert_user(self, user, task):
        # type: (User, Task) -> None
        '''
        Alerts a user about an alert that was trigged and associated with their
        name.

        Args:
            user (User): The user associated with the task.
            task (Task): A task to alert on.
        '''
        # Format the reason to be indented
        reason = '\n'.join(['>' + s for s in task.reason.split('\n')])

        message = self.messages['alert'].format(task.description, reason)
        message += '\n'
        message += self.messages['action_prompt']
        self.chat.message_user(user, message)

    # User creation and lookup methods

    def _populate_users(self):
        # type: () -> None
        '''
        Populates the members dictionary mapping user IDs to username, avatar,
        etc.
        '''
        logging.info('Gathering information about all team members...')
        members = self.chat.get_users()
        for member in members:
            user = User(member, self.auth_builder(member['name']), self)
            self.users[member['id']] = user
            self.users_by_name[member['name']] = user
        logging.info('Gathered info on {} users.'.format(len(self.users)))

    def user_lookup(self, id):
        # type: (str) -> User
        '''
        Looks up a user by their ID.

        Args:
            id (str): The ID of a user to look up, formatted like U12345678.
        Returns:
            (dict): All known information about that user.
        '''
        if id not in self.users:
            raise SecurityBotException('User {} not found'.format(id))
        return self.users[id]

    def user_lookup_by_name(self, username):
        # type: (str) -> User
        '''
        Looks up a user by their username.

        Args:
            username (str): The username of the user to look up.
        Resturns:
            (dict): All known information about that user.
        '''
        if username not in self.users_by_name:
            raise SecurityBotException('User {} not found'.format(username))
        return self.users_by_name[username]

    # Chat methods

    def greet_user(self, user):
        # type: (User) -> None
        '''
        Sends a greeting message to a user.

        Args:
            user (User): The user to greet.
        '''
        self.chat.message_user(user, self.messages['greeting'].format(user.get_name()))

    # Command functions
    def is_command(self, command):
        # type: (str) -> bool
        '''Checks if a raw command is a command.'''
        return clean_command(command.split()[0]) in self.commands

    def parse_command(self, command):
        # type: (str) -> Tuple[str, List[str]]
        '''
        Parses a given command.

        Args:
            command (str): The raw command to parse.
        Returns:
            (str, List[str]): A tuple of the command followed by arguments.
        '''
        # First try shlex
        command = clean_input(command)
        try:
            split = shlex.split(command)
        except ValueError:
            # ignore shlex exception
            # Fall back to naive method
            split = command.split()

        return (clean_command(split[0]), split[1:])

class SecurityBotException(Exception):
    pass


================================================
File: /securitybot/user.py
================================================
'''
An object to manage user interactions.
Wraps user information, all known alerts, and an active DM channel with the user.
'''
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

import logging
import pytz
from datetime import datetime, timedelta
import securitybot.ignored_alerts as ignored_alerts
from securitybot.tasker.tasker import Task
from securitybot.auth.auth import AUTH_STATES
from securitybot.state_machine import StateMachine
from securitybot.util import tuple_builder, get_expiration_time

from typing import Any, Dict, List

ESCALATION_TIME = timedelta(hours=2)
BACKOFF_TIME = timedelta(hours=21)

class User(object):
    '''
    A user to be contacted by the security bot. Each user stores all of the
    information provided by chat, which is indexable similar to a dictionary.
    A user also holds a reference to an authentication object for 2FA and the
    bot who spawned it for sending messages.
    '''

    def __init__(self, user, auth, parent):
        # type: (Dict[str, Any], Any, Any) -> None
        '''
        Args:
            user (dict): Chat information about a user.
            auth (Auth): The authentication object to use.
            parent (Bot): The bot object that spawned this user.
        '''
        self._user = user # type: Dict[str, Any]
        self.tasks = [] # type: List[Task]
        self.pending_task = None # type: Task
        # Authetnication object specific to this user
        self.auth = auth

        # Parent pointer to bot
        self.parent = parent

        # Last parsed message from this user
        self._last_message = tuple_builder()

        # Last authorization status
        self._last_auth = AUTH_STATES.NONE

        # Task auto-escalation time
        self._escalation_time = datetime.max.replace(tzinfo=pytz.utc)

        # Build state hierarchy
        states = ['need_task',
                  'action_performed_check',
                  'auth_permission_check',
                  'waiting_on_auth',
                  'task_finished',
                  ]
        transitions = [
            # Handle new tasks
            {
                'source': 'need_task',
                'dest': 'action_performed_check',
                'condition': self._has_tasks
            },
            # Finish task if user says action was performed and recently authorized
            {
                'source': 'action_performed_check',
                'dest': 'task_finished',
                'condition': self._already_authed,
            },
            # Finish task if user says action was performed and no 2FA capability exists
            {
                'source': 'action_performed_check',
                'dest': 'task_finished',
                'condition': self._cannot_2fa,
                'action': lambda: self.send_message('no_2fa')
            },
            # Ask for 2FA if user says action was performed and can do 2FA
            {
                'source': 'action_performed_check',
                'dest': 'auth_permission_check',
                'condition': self._performed_action,
            },
            # Finish task if user says action wasn't performed
            {
                'source': 'action_performed_check',
                'dest': 'task_finished',
                'condition': self._did_not_perform_action,
                'action': self._act_on_not_performed,
            },
            # Silently escalate and wait after some time goes by
            {
                'source': 'action_performed_check',
                'dest': 'task_finished',
                'condition': self._slow_response_time,
                'action': self._auto_escalate,
            },
            # Perform 2FA if permission is granted
            {
                'source': 'auth_permission_check',
                'dest': 'waiting_on_auth',
                'condition': self._allows_authorization,
            },
            # Don't perform 2FA if permission is not granted
            {
                'source': 'auth_permission_check',
                'dest': 'task_finished',
                'condition': self._denies_authorization,
                'action': lambda: self.send_message('escalated'),
            },
            # Silently escalate and wait after some time goes by again
            {
                'source': 'auth_permission_check',
                'dest': 'task_finished',
                'condition': self._slow_response_time,
                'action': self._auto_escalate,
            },
            # Wait for authorization response then finish the task
            {
                'source': 'waiting_on_auth',
                'dest': 'task_finished',
                'condition': self._auth_completed,
            },
            # Go to the first needed task, possibly quitting, when task is completed
            {
                'source': 'task_finished',
                'dest': 'need_task',
            },
        ]
        during = {
            'waiting_on_auth': self._update_auth,
        }
        on_enter = {
            'auth_permission_check': lambda: self.send_message('2fa'),
            'waiting_on_auth': lambda: self.begin_auth(),
        }
        on_exit = {
            'need_task': self._next_task,
            'action_performed_check': self._update_task_response,
            'auth_permission_check': self._reset_message,
            'waiting_on_auth': self._update_task_auth,
            'task_finished': self._complete_task,
        }

        self._fsm = StateMachine(states, transitions, 'need_task', during=during, on_enter=on_enter,
                                 on_exit=on_exit)

    def __getitem__(self, key):
        # type: (str) -> Any
        '''
        Allows for indexing on the user infomation pulled from our chat system.
        '''
        return self._user.get(key, None)

    def step(self):
        # type: () -> None
        self._fsm.step()

    def _update_auth(self):
        # type: () -> None
        self._last_auth = self.auth_status()

    # State conditions

    def _has_tasks(self):
        # type: () -> bool
        '''Checks if the user has any tasks.'''
        return len(self.tasks) != 0

    def _already_authed(self):
        # type: () -> bool
        '''
        Checks if the user performed the last action and
        if they are already authorized.
        '''
        return self._performed_action() and self.auth_status() == AUTH_STATES.AUTHORIZED

    def _cannot_2fa(self):
        # type: () -> bool
        return self._performed_action() and not self.auth.can_auth()

    def _performed_action(self):
        # type: () -> bool
        '''Checks if the user performed their current action.'''
        return self._last_message.answer is True

    def _did_not_perform_action(self):
        # type: () -> bool
        '''Checks if the user _did not_ perform their current action.'''
        return self._last_message.answer is False

    def _slow_response_time(self):
        # type: () -> bool
        '''Returns true if the user has taken a long time to respond.'''
        return datetime.now(tz=pytz.utc) > self._escalation_time

    def _allows_authorization(self):
        # type: () -> bool
        '''Checks if the user is okay with 2FA.'''
        return self._last_message.answer is True

    def _denies_authorization(self):
        # type: () -> bool
        '''Checks if the user is not okay with 2FA.'''
        return self._last_message.answer is False

    def _auth_completed(self):
        # type: () -> bool
        '''Checks if authentication has been completed.'''
        return self._last_auth is AUTH_STATES.AUTHORIZED or self._last_auth is AUTH_STATES.DENIED

    # State actions

    def _auto_escalate(self):
        # type: () -> None
        '''Marks the current task as needing verification and moves on.'''
        logging.info('Silently escalating {0} for {1}'
                        .format(self.pending_task.description, self['name']))
        # Append in the case that this is called when waiting for auth permission
        self.pending_task.comment += 'Automatically escalated. No response received.'
        self.pending_task.set_verifying()
        self._escalation_time = datetime.max.replace(tzinfo=pytz.utc)
        self.send_message('no_response')

    def _act_on_not_performed(self):
        # type: () -> None
        '''
        Acts on a user not performing an action.
        Sends a message and alerts the bot's reporting channel.
        '''
        # Send escalation method
        self.send_message('escalated')
        # Alert bot's reporting channel
        if self.parent.reporting_channel is not None:
            # Format message
            if self._last_message.text:
                comment = self._last_message.text
            else:
                comment = 'No comment provided.'
            comment = '\n'.join('> ' + s for s in comment.split('\n'))
            self.parent.chat.send_message(
                self.parent.reporting_channel,
                self.parent.messages['report'].format(username=self['name'],
                                                      title=self.pending_task.title,
                                                      description=self.pending_task.description,
                                                      comment=comment,
                                                      url=self.pending_task.url))


    # Exit actions

    def _update_task_response(self):
        # type: () -> None
        '''
        Updates the task with information gained from the user's response.
        '''
        if self._last_message.answer is not None:
            self.pending_task.performed = self._last_message.answer
            self.pending_task.comment = self._last_message.text

        self._reset_message()

    def _update_task_auth(self):
        # type: () -> None
        '''
        Updates the task with authorization permission.
        '''
        if self._last_auth is AUTH_STATES.AUTHORIZED:
            self.send_message('good_auth')
            self.pending_task.authenticated = True
        else:
            self.send_message('bad_auth')
            self.reset_auth()
            self.pending_task.authenticated = False

    def _reset_message(self):
        # type: () -> None
        self._last_message = tuple_builder()

    # Task methods

    def add_task(self, task):
        # type: (Task) -> None
        '''
        Adds a task to this user's new tasks.

        Args:
            task (Task): The Task to add.
        '''
        self.tasks.append(task)
        self._update_tasks()

    def _next_task(self):
        # type: () -> None
        '''
        Advances to the next task if there is no pending task and alerts the
        user of its existence.
        '''
        self.pending_task = self.tasks.pop(0)
        self.parent.alert_user(self, self.pending_task)
        self._reset_message()
        self._escalation_time = get_expiration_time(datetime.now(tz=pytz.utc), ESCALATION_TIME)
        logging.info('Beginning task for {0}'.format(self['name']))

    def _complete_task(self):
        # type: () -> None
        '''
        Completes the user's pending task. If any remaining tasks exist, sends
        a message alerting the user of more. Otherwise sends a farewell message
        and removes itself from the bot.
        '''
        # Ignore an alert if they did it
        if self.pending_task.performed:
            ignored_alerts.ignore_task(self['name'], self.pending_task.title,
                                       'auto backoff after confirmation', BACKOFF_TIME)
        self.pending_task.set_verifying()
        self.pending_task = None
        self._reset_message()
        self._update_tasks()
        if self.tasks:
            self.send_message('bwtm')
        else:
            self.send_message('bye')
            self.parent.cleanup_user(self)

    def _update_tasks(self):
        # type: () -> None
        '''
        Updates the user's stored list of tasks, removing all of those that should be ignored.
        '''
        ignored = ignored_alerts.get_ignored(self['name'])
        cleaned_tasks = []
        for task in self.tasks:
            if task.title in ignored:
                logging.info('Ignoring task {0} for {1}'.format(task.title, self['name']))
                task.comment = ignored[task.title]
                task.set_verifying()
            else:
                cleaned_tasks.append(task)
        self.tasks = cleaned_tasks

    # Message methods

    def positive_response(self, text):
        # type: (str) -> None
        '''
        Registers a positive response having been received.

        Args:
            text (str): Some message accompanying the response.
        '''
        self._last_message = tuple_builder(True, text)

    def negative_response(self, text):
        # type: (str) -> None
        '''
        Registers a negative response having been received.

        Args:
            text (str): Some message accompanying the response.
        '''
        self._last_message = tuple_builder(False, text)

    def send_message(self, key):
        # type: (str) -> None
        '''
        Sends a message from the pre-loaded messages.yaml.

        Args:
            key (str): The key in messages.yaml of the message to send.
        '''
        self.parent.chat.message_user(self, self.parent.messages[key])

    # Authorization methods

    def begin_auth(self):
        # type: () -> None
        '''
        Attempts to authorize this user. Changes the user's state to
        WAITING_ON_AUTH.
        '''
        self.send_message('sending_push')
        self.auth.auth(self.pending_task.description)

    def auth_status(self):
        # type: () -> int
        '''
        Gets the current authorization status.
        '''
        return self.auth.auth_status()

    def reset_auth(self):
        # type: () -> None
        '''
        Resets this user's authorization status, including no longer accepting
        authorization due to being "recently" authorized.
        '''
        self.auth.reset()

    # Utility methods

    def get_name(self):
        # type: () -> str
        '''
        Tries to find the best name to use when talking to a user.
        '''
        if ('profile' in self._user and
                'first_name' in self._user['profile'] and
                self._user['profile']['first_name']):
            return self._user['profile']['first_name']
        return self._user['name']

class UserException(Exception):
    pass


================================================
File: /securitybot/util.py
================================================
__author__ = 'Alex Bertsch'
__email__ = 'abertsch@dropbox.com'

import pytz
import binascii
import os
from datetime import datetime, timedelta
from collections import namedtuple

from securitybot.sql import SQLEngine

# http://stackoverflow.com/questions/36932/how-can-i-represent-an-enum-in-python
def enum(*sequential, **named):
    enums = dict(zip(sequential, range(len(sequential))), **named)
    return type('Enum', (), enums)

def tuple_builder(answer=None, text=None):
    tup = namedtuple('Response', ['answer', 'text'])
    tup.answer = answer if answer is not None else None
    tup.text = text if text is not None else ''
    return tup

OPENING_HOUR = 10
CLOSING_HOUR = 18
LOCAL_TZ = pytz.timezone('America/Los_Angeles')

def during_business_hours(time):
    '''
    Checks if a given time is within business hours. Currently is true
    from 10:00 to 17:59. Also checks to make sure that the day is a weekday.

    Args:
        time (Datetime): A datetime object to check.
    '''
    if time.tzinfo is not None:
        here = time.astimezone(LOCAL_TZ)
    else:
        here = time.replace(tzinfo=pytz.utc).astimezone(LOCAL_TZ)
    return (OPENING_HOUR <= here.hour < CLOSING_HOUR and
            1 <= time.isoweekday() <= 5)

def get_expiration_time(start, time):
    '''
    Gets an expiration time for an alert.
    Works by adding on a certain time and wrapping around after business hours
    so that alerts that are started near the end of the day don't expire.

    Args:
        start (Datetime): A datetime object indicating when an alert was started.
        time (Timedelta): A timedelta representing the amount of time the alert
            should live for.
    Returns:
        Datetime: The expiry time for an alert.
    '''
    if start.tzinfo is None:
        start = start.replace(tzinfo=pytz.utc)
    end = start + time
    if not during_business_hours(end):
        end_of_day = datetime(year=start.year,
                              month=start.month,
                              day=start.day,
                              hour=CLOSING_HOUR,
                              tzinfo=LOCAL_TZ)
        delta = end - end_of_day
        next_day = end_of_day + timedelta(hours=(OPENING_HOUR - CLOSING_HOUR) % 24)
        # This may land on a weekend, so march to the next weekday
        while not during_business_hours(next_day):
            next_day += timedelta(days=1)
        end = next_day + delta
    return end

def create_new_alert(title, ldap, description, reason, url='N/A', key=None):
    # type: (str, str, str, str, str, str) -> None
    '''
    Creates a new alert in the SQL DB with an optionally random hash.
    '''
    # Generate random key if none provided
    if key is None:
        key = binascii.hexlify(os.urandom(32))

    # Insert that into the database as a new alert
    SQLEngine.execute('''
    INSERT INTO alerts (hash, ldap, title, description, reason, url, event_time)
    VALUES (UNHEX(%s), %s, %s, %s, %s, %s, NOW())
    ''',
    (key, ldap, title, description, reason, url))

    SQLEngine.execute('''
    INSERT INTO user_responses (hash, comment, performed, authenticated)
    VALUES (UNHEX(%s), '', false, false)
    ''',
    (key,))

    SQLEngine.execute('INSERT INTO alert_status (hash, status) VALUES (UNHEX(%s), 0)',
                      (key,))


================================================
File: /securitybot/sql.py
================================================
'''
A wrapper for the securitybot to access its database.
'''
import MySQLdb
import logging

from typing import Any, Sequence

class SQLEngine(object):
    # Whether the singleton has been instantiated
    _host = None # type: str
    _user = None # type: str
    _passwd = None # type: str
    _db = None # type: str
    _created = False # type: bool
    _conn = None
    _cursor = None

    def __init__(self, host, user, passwd, db):
        # type: (str, str, str, str) -> None
        '''
        Initializes the SQL connection to be used for the bot.

        Args:
            host (str): The hostname of the SQL server.
            user (str): The username to use.
            passwd (str): Password for MySQL user.
            db (str): The name of the database to connect to.
        '''
        if not SQLEngine._created:
            SQLEngine._host = host
            SQLEngine._user = user
            SQLEngine._passwd = passwd
            SQLEngine._db = db
            SQLEngine._create_engine(host, user, passwd, db)
            SQLEngine._created = True

    @staticmethod
    def _create_engine(host, user, passwd, db):
        # type: (str, str, str, str) -> None
        '''
        Args:
            host (str): The hostname of the SQL server.
            user (str): The username to use.
            passwd (str): Password for MySQL user.
            db (str): The name of the database to connect to.
        '''
        SQLEngine._conn = MySQLdb.connect(host=host,
                                        user=user,
                                        passwd=passwd,
                                        db=db)
        SQLEngine._cursor = SQLEngine._conn.cursor()

    @staticmethod
    def execute(query, params=None):
        # type: (str, Sequence[Any]) -> Sequence[Sequence[Any]]
        '''
        Executes a given SQL query with some possible params.

        Args:
            query (str): The query to perform.
            params (Tuple[str]): Optional parameters to pass to the query.
        Returns:
            Tuple[Tuple[str]]: The output from the SQL query.
        '''
        if params is None:
            params = ()
        try:
            SQLEngine._cursor.execute(query, params)
            rows = SQLEngine._cursor.fetchall()
            SQLEngine._conn.commit()
        except (AttributeError, MySQLdb.OperationalError):
            # Recover from lost connection
            logging.warn('Recovering from lost MySQL connection.')
            SQLEngine._create_engine(SQLEngine._host,
                                     SQLEngine._user,
                                     SQLEngine._passwd,
                                     SQLEngine._db)
            return SQLEngine.execute(query, params)
        except MySQLdb.Error as e:
            try:
                raise SQLEngineException('MySQL error [{0}]: {1}'.format(e.args[0], e.args[1]))
            except IndexError:
                raise SQLEngineException('MySQL error: {0}'.format(e))
        return rows

class SQLEngineException(Exception):
    pass

def init_sql():
    # type: () -> None
    '''Initializes SQL.'''
    SQLEngine('localhost', 'root', '', 'securitybot')


================================================
File: /requirements.txt
================================================
backports-abc==0.4
certifi==2016.8.8
configparser==3.5.0
duo-client==3.0
enum34==1.1.6
flake8==3.0.4
funcsigs==1.0.2
linecache2==1.0.0
mccabe==0.5.2
mock==2.0.0
MySQL-python==1.2.5
nose==1.3.7
pbr==1.10.0
py==1.4.31
pycodestyle==2.0.0
pyflakes==1.2.3
pytest==3.0.1
pytz==2016.6.1
PyYAML==3.11
requests==2.11.1
singledispatch==3.4.0.3
six==1.10.0
slackclient==1.0.1
tornado==4.4.1
traceback2==1.4.0
typing==3.5.2.2
unittest2==1.1.0
websocket-client==0.37.0


================================================
File: /config/commands.yaml
================================================
---
# Securitybot commands
# Each command must have an information string and function to call.
# They may also excplitly say whether they are hidden and provide their usage along with
# success and failure messages, located in messages.yaml

help: # Displays each command, their info and useage
    info: This display here.
    usage:
        - "-a\t\tShow all commands, including ones hidden by default"
    fn: help

hi: # Says hello!
    info: Hi!
    fn: hi

stop: # Adds a user to the blacklist
    info: Adds you to the blacklist.
    fn: add_to_blacklist
    success_msg: Alright, you've been added to the blacklist. I won't bother you anymore.
    failure_msg: Looks like you're already on the blacklist.

start: # Removes a user from the blacklist
    info: Removes you from the blacklist.
    fn: remove_from_blacklist
    success_msg: You're off the blacklist. Welcome back!
    failure_msg: Looks like you're not on the blacklist.

"yes": # Registers a positive response for a user
    info: Registers a positive response from you.
    fn: positive_response
    hidden: Yes

"no": # Registers a negative reponse for a user
    info: Registers a negative response from you.
    fn: negative_response
    hidden: Yes

ignore: # Ignores the user for one or more alerts for some period of time
    info: Ignores the current alert or previous alert if there is no current alert.
    usage:
        - "`ignore (last|current) XhYm`"
        - "Ignores an alert for X hours and Y minutes. At least one of hours or minutes must be provided."
        - "Selectable whether this ignores the current alert
           (whatever the bot is bothering you about right now) or the last one
           (whichever one you just dealt with)."
    fn: ignore
    success_msg: >
        Alright, I'll stop bothering you about that for now.
        You'll need to finish up your current alert if you chose to ignore it in the future.
    failure_msg: Sorry, either that command was malformed or you have no alerts to ignore.

test: # Generates a test alert for a user
    info: Generates a test alert for you.
    fn: test
    hidden: Yes
    success_msg: 'Sending you a testing alert. Be patient...'
    failure_msg: 'I was unable to generate a testing alert. Sorry. :sadpanda:'

...


================================================
File: /config/bot.yaml
================================================
---
messages_path: config/messages.yaml
commands_path: config/commands.yaml
...


================================================
File: /config/messages.yaml
================================================
---
# Messages for securitybot
# This file is loaded, parsed and fed into the bot.

# Basic bot greeting.
# Formatting parameter 0 is the name to use when addressing the user.
greeting: >
    Hi there {0}!

    Feel free to message me `help` for some commands you can use, e.g `stop` or `ignore`.

# Message to send between alerts. (but wait there's more)
bwtm: >
    One more thing...

# Message to send once all current alerts have been dealt with
bye: >
    Thanks for your help!

# Message sent when alerting a user that a security action occured
# Takes alert description and alert reason as formatting parameters 0 and 1 rsp
alert: >
    There's an alert, `{0}`, that's associated with your username.

    Here's some more information on the alert:

    {1}

# Message sent when asking for user response on whether they're responsible
action_prompt: >
    Did you do this?

    Respond with either "yes" or "no" followed by an explanation in one message.

# Message sent if the user is not responsible
escalated: >
    That's fine. Don't worry, I'll share this with the security team and they'll
    look into this and get back to you if they need more.

# Message sent when no 2FA is available
no_2fa: >
    It doesn't look like you have 2FA set up on your account.

# Message sent when asking for 2FA
2fa: >
    Great! To confirm this I'm going to send a 2FA to your device.
    Are you okay with that? Respond with either "yes" or "no" on their own.

# Message send when sending a 2FA
sending_push: >
    I'm sending you a 2FA right now. Check to make sure that it's from me
    and then feel free to accept it.

# Message sent on 2FA approval
good_auth: >
    Awesome, I've noted what you've said and should take care of this.

# Message sent on 2FA denial
bad_auth: >
    Sadly that 2FA request didn't go through...

    The task has been shared with the security team who will look into it
    shortly. They'll get back to you when they can.

# Message sent when a bad resposne is retrieved
bad_response: >
    Sorry, I didn't understand that. Try again, please.

# Message sent when automatically escalating a task
no_response: >
    I didn't hear anything from you, so I'll just send that off to the security team and they'll
    contact you soon if needed.

# Message sent to report a user didn't do something.
report: >
    `{username}` reports they didn't do `{title}` (`{description}`):

    {comment}

    URL: {url}

# Sent when a message is unrecognized
bad_command: >
    I'm sorry, I don't understand. Try saying `help` for more information.

# Command messages
help_header: >
    Securitybot commands:

help_usage: Usage

help_footer: >
    Treat these like terminal commands; you can pass in flags and parameters.

hi: >
    Hello there {0}!

ignore_time: >
    Ignoring specific alerts is limited to just four hours.
    I've reduced the amount of time to that limit.

ignore_no_time: >
    You must provide a non-zero amount of time.
...


================================================
File: /util/db_up.py
================================================
#!/usr/bin/env python
import MySQLdb
import sys

# DB CONFIG GOES HERE
host = 'localhost'
user = 'root'
passwd= ''

db = MySQLdb.connect(host=host,
                     user=user,
                     passwd=passwd,
                     db='securitybot')

cur = db.cursor()

# Start fresh
print 'Removing all tables'
cur.execute('SHOW TABLES')
tables = cur.fetchall()
for table in tables:
    table = table[0]
    print 'Dropping {0}'.format(table)
    cur.execute('DROP TABLE {0}'.format(MySQLdb.escape_string(table)))

# Create tables
print 'Creating tables...'

cur.execute(
'''
CREATE TABLE blacklist (
   ldap VARCHAR(255) NOT NULL,
   PRIMARY KEY ( ldap )
)
'''
)

cur.execute(
'''
CREATE TABLE ignored (
    ldap VARCHAR(255) NOT NULL,
    title VARCHAR(255) NOT NULL,
    reason VARCHAR(255) NOT NULL,
    until DATETIME NOT NULL,
    CONSTRAINT ignored_ID PRIMARY KEY ( ldap, title )
)
'''
)

cur.execute(
'''
CREATE TABLE alerts (
    hash BINARY(32) NOT NULL,
    ldap VARCHAR(255) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description VARCHAR(255) NOT NULL,
    reason TEXT NOT NULL,
    url VARCHAR(511) NOT NULL,
    event_time DATETIME NOT NULL,
    PRIMARY KEY ( hash )
)
'''
)

cur.execute(
'''
CREATE TABLE alert_status (
    hash BINARY(32) NOT NULL,
    status TINYINT UNSIGNED NOT NULL,
    PRIMARY KEY ( hash )
)
'''
)

cur.execute(
'''
CREATE TABLE user_responses(
    hash BINARY(32) NOT NULL,
    comment TEXT,
    performed BOOL,
    authenticated BOOL,
    PRIMARY KEY ( hash )
)
'''
)

print 'Done!'


================================================
File: /frontend.py
================================================
#!/usr/local/env python
import argparse
from frontend.securitybot_frontend import main, init

if __name__ == '__main__':
    init()

    parser = argparse.ArgumentParser(description='Securitybot frontent')
    parser.add_argument('--port', dest='port', default='8888', type=int)
    args = parser.parse_args()

    main(args.port)


================================================
File: /LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


================================================
File: /README.md
================================================
# Securitybot
### Distributed alerting for the masses!
Securitybot is an open-source implementation of a distributed alerting chat bot, as described in Ryan Huber's [blog post][slack-blog].
Distributed alerting improves the monitoring efficiency of your security team and can help you catch security incidents faster and more efficiently.
We've tried to remove all Dropbox-isms from this code so that setting up your own instance should be fairly painless.
It should be relatively easy to install the listed requirements in a virtualenv/Docker container and simply have the bot do its thing.
We also provide a simple front end to dive through the database, receive API calls, and create custom alerts for the bot to reach out to people as desired.

## Deploying
This guide runs through setting up a Securitybot instance as quickly as possible with no frills.
We'll be connecting it to Slack, SQL, and Duo.
Once we're done, we'll have a file that looks something like `main.py`.

### SQL
You'll need a database called `securitybot` on some MySQL server somewhere.
We've provided a function called `init_sql` located in `securitybot/sql.py` that will initialize SQL.
Currently it's set up to use the host `localhost` with user `root` and no password.
You'll need to change this because of course that's not how your database is set up.

### Slack
You'll need a token to be able to integrate with Slack.
The best thing to do would be to [create a bot user][bot-user] and use that token for Securitybot.
You'll also want to set up a channel to which the bot will report when users specify that they haven't performed an action.
Find the unique ID for that channel (it'll look similar to `C123456`) and be sure to invite the bot user into that channel, otherwise it won't be able to send messages.

### Duo
For Duo, you'll want to create an [Auth API][auth-api] instances, name it something clever, and keep track of the integration key, secret key, and auth API endpoint URI.

### Running the bot
Take a look at the provided `main.py` in the root directory for an example on how to use all of these.
Replace all of the global variables with whatever you found above.
If the following were all generated successfully, Securitybot should be up and running.
To test it, message the bot user it's assigned to and say `hi`.
To test the process of dealing with an alert, message `test` to test the bot.

## Architecture
Securitybot was designed to be as modular as possible.
This means that it's possible to easily swap out chat systems, 2FA providers, and alerting data sources.
The only system that is tightly integrated with the bot is SQL, but adding support for other databases shouldn't be difficult.
Having a database allows alerts to be persistent and means that the bot doesn't lose (too much) state if there's some transient failure.

### Securitybot proper
The bot itself performs a small set of functions:

1. Reads messages, interpreting them as commands.
1. Polls each user object to update their state of applicable.
1. Grabs new alerts from the database and assigns them to users or escalates on an unknown user.

Messaging, 2FA, and alert management are provided by configurable modules, and added to the bot upon initialization.

#### Commands
The bot handles incoming messages as commands.
Command parsing and handling is done in the `Securitybot` class and the commands themselves are provided in two places.
The functions for the commands are defined in `commands.py` and their structure is defined in `commands.yaml` under the `config/` directory.

### Messaging
Securitybot is designed to be compatible with a wide variety of messaging systems.
We currently provide bindings for Slack, but feel free to contribute any other plugins, like for Gitter or Zulip, upstream.
Messaging is made possible by `securitybot/chat/chat.py` which provides a small number of functions for querying users in a messaging group, messaging those users, and sending messages to a specific channel/room.
To add bindings for a new messaging system, subclass `Chat`.

### 2FA
2FA support is provided by `auth/auth.py`, which wraps async 2FA in a few functions that enable checking for 2FA capability, starting a 2FA session, and polling the state of the 2FA session.
We provide support for Duo Push via the Duo Auth API, but adding support for a different product or some in-house 2FA solution is as easy as creating a subclass of `Auth`.

### Task management
Task management is provided by `tasker/tasker.py` and the `Tasker` class.
Since alerts are logged in an SQL database, the provided Tasker is `SQLTasker`.
This provides support for grabbing new tasks and updating them via individual `Task` objects.

### Blacklists
Blacklists are handled by the SQL database, provided in `blacklist/blacklist.py` and the subclass `blacklist/sql_blacklist.py`.

### Users
The `User` object provides support for handling user state.
We keep track of whatever information a messaging system gives to us, but really only ever use a user's unique ID and username in order to contact them.

### Alerts
Alerts are uniquely identified by a SHA-256 hash which comes from some hash of the event that generated them.
We assume that a SHA-256 hash is sufficiently random for there to be no collisions.
If you encounter a SHA-256 collision, please contact someone at your nearest University and enjoy the fame and fortune it brings upon you.

## FAQ

Please ask us things

## Contributing
Contributors must abide by the [Dropbox Contributor License Agreement][cla].

## License

Copyright 2016 Dropbox, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.



[slack-blog]: https://slack.engineering/distributed-security-alerting-c89414c992d6 "Distributed Alerting"
[bot-user]: https://api.slack.com/bot-users "Slack Bot Users"
[auth-api]: https://duo.com/docs/authapi "Duo Auth API"
[cla]: https://opensource.dropbox.com/cla/ "Dropbox CLA"


